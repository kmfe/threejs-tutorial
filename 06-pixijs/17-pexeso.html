<!doctype html>
<html lang='en'>
<head>
  <meta charset='UTF-8'>
  <meta name='viewport'
    content='width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0'>
  <meta http-equiv='X-UA-Compatible' content='ie=edge'>
  <title>pixi.js tutorial</title>
  <script src='./lib/tween.umd.js'></script>
  <script src='./lib/pixi.js'></script>
  <script src='./lib/pixi-sound.js'></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
      'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
      'Noto Color Emoji';
    }
    
    ul, li {
      list-style: none;
    }
    
    html, body {
    }
    
    .playground canvas {
      display: block;
      margin: 0 auto;
    }
    
    .game-title {
      text-align: center;
      font-size: 24px;
      line-height: 2;
    }
    
    .game-info {
      margin: 30px auto;
      width: 80%;
      line-height: 1.2;
    }
    
    .game-info section {
      margin-bottom: 20px;
    }
    
    .game-info__title {
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
<h1 class='game-title'>Pexeso</h1>
<div class='playground'></div>
<div class='game-info'>
  <section>
    <h3 class='game-info__title'>Training focus</h3>
    <div class='game-info__desc'>
      <ul>
        <li>Short-term visual memory</li>
        <li>Attention span</li>
      </ul>
    </div>
  </section>
  <section>
    <h3 class='game-info__title'>Principles of the training</h3>
    <div class='game-info__desc'>
      <ul>
        <li>
          This is a classic memory game where the player’s goal is to turn over pairs of cards with matching symbols.
          This simple game develops primarily short-term memory and concentration on multiple objects simultaneously.
          Thanks to its simplicity, the game is also suitable for the youngest children.
        </li>
      </ul>
    </div>
  </section>
  <section>
    <h3 class='game-info__title'>How to play this game</h3>
    <div class='game-info__desc'>
      <p>
        The main goal of the game is to find all the pairs of cards with the same symbol. When the players mark all the
        pairs, they can advance to the next level.
      </p>
    </div>
  </section>
</div>
<script>
	const options = {
		width: 615,
		height: 505,
		transparent: false,
		backgroundColor: 0XEEEEEE
	}
	const app = new PIXI.Application(options)
	let clickSound, successSound, errorSound, flipSound
	const countTime = 1000
	let angle = 30
	
	function initSound () {
		// 声音
		const manifest = {
			success: './assets/sound/success.mp3',
			click: './assets/sound/click.mp3',
			error: './assets/sound/error.mp3',
			levelwon: './assets/sound/levelwon.mp3',
			flip: './assets/sound/flip.mp3'
		}
		
		// add to PIXI loader
		PIXI.sound.volumeAll = 100
		for (let resource in manifest) {
			PIXI.Loader.shared.add(resource, manifest[resource])
		}
		// preload the sounds
		PIXI.Loader.shared.load(function (loader, resources) {
			clickSound = resources['click'].sound
			successSound = resources['success'].sound
			errorSound = resources['error'].sound
			flipSound = resources['flip'].sound
		})
	}
	
	const playground = document.querySelector('.playground')
	playground.appendChild(app.view)
	
	const centerX = app.renderer.view.width / 2
	const centerY = app.renderer.view.height / 2
	const loader = new PIXI.Loader()
	const Sprite = PIXI.Sprite
	const Texture = PIXI.Texture
	
	let currentScene = 0
	
	let playBtnActiveTexture, playBtnTexture, playButton,
		welcomeScene, introScene, gameScene,
		correctBtn, failBtn,
		countOne, countTwo, countThree, counterInterval, countSet = [],
		correctAnswerNum = 0,
		textureCache,
		level = 1, cardGroup,
		lowLevelFlipTime = 5000,
		highLevelFlipTime = 10000,
		flipInterval = null
	
	let transform = {
		x: 0
	}
	let introTransform = {
		posX: -centerX * 2
	}
	let gameTransform = {
		x: -centerX * 2
	}
	
	// 加载图片转化成纹理
	loader
	.add('welcome', './assets/pexeso/en/title_screen.png')
	.add('intro', './assets/pexeso/en/instructions.png')
	.add('correctImg', './assets/pexeso/common/sign_ok.png')
	.add('failImg', './assets/pexeso/common/sign_fail.png')
	
	.add('karta1', './assets/pexeso/common/karta01.png')
	.add('karta2', './assets/pexeso/common/karta02.png')
	.add('karta3', './assets/pexeso/common/karta03.png')
	.add('karta4', './assets/pexeso/common/karta04.png')
	.add('karta5', './assets/pexeso/common/karta05.png')
	.add('karta6', './assets/pexeso/common/karta06.png')
	.add('karta7', './assets/pexeso/common/karta07.png')
	.add('karta8', './assets/pexeso/common/karta08.png')
	.add('karta9', './assets/pexeso/common/karta09.png')
	.add('karta10', './assets/pexeso/common/karta10.png')
	.add('karta11', './assets/pexeso/common/karta11.png')
	.add('cardBack', './assets/pexeso/common/karta_zadek.png')
	
	.add('gameBackground', './assets/pexeso/common/gameBackground.png')
	.add('playBtn', './assets/pexeso/en/button_play.png')
	.add('counts', './assets/pexeso/common/counts.png')
	.load(setup)
	
	// 补零
	function zeroFill (num) {
		return num < 10 ? '0' + num : num
	}
	
	// 不包含最大值，用于在取数组中任意数
	function getRangeNum (min, max) {
		return Math.floor(Math.random() * (max - min)) + min
	}
	
	// shuffle array，数组混淆
	function shuffle (array) {
		for (let i = array.length - 1; i > 0; i--) {
			let j = Math.floor(Math.random() * (i + 1));
			[array[i], array[j]] = [array[j], array[i]]
		}
	}
	
	// 游戏业务代码
	// 目标是：两次点击选中相同symbol的卡片，否则重新选择
	
	function renderGameLogic () {
		if (cardGroup !== undefined && cardGroup.children.length) {
			gameScene.removeChild(cardGroup)
			if (flipInterval) clearTimeout(flipInterval)
			correctAnswerNum = 0
		}
		
		const row = level + 1 > 4 ? 4 : level + 1
		const col = 4
		const cards = []
		for (let i = 1; i <= 11; i++) {
			cards.push(textureCache['karta' + i])
		}
		cardGroup = new PIXI.Container()
		const cardBack = textureCache['cardBack']
		const cardsGrid = row * col
		
		// 生成grid
		const cardsGridSprites = []
		const currentCards = []
		while (cardsGridSprites.length < cardsGrid / 2) {
			let temp = getRangeNum(0, cards.length)
			if (!cardsGridSprites.includes(temp)) {
				cardsGridSprites.push(temp)
			}
		}
		
		cardsGridSprites.push(...cardsGridSprites)
		
		shuffle(cardsGridSprites)
		
		let scale = {
			x: 0.8
		}
		
		for (let i = 0; i < cardsGridSprites.length; i++) {
			let card = new Sprite(cards[cardsGridSprites[i]])
			card.anchor.set(0.5)
			card.name = cardsGridSprites[i]
			card.scale.set(scale.x, 0.8, 0.8)
			card.x = (i % col) * 80 + card.width / 2
			card.y = Math.floor(i / col) * 80 + card.height / 2
			cardGroup.addChild(card)
			currentCards.push({
				sprite: card,
				texture: cards[cardsGridSprites[i]],
				process: false
			})
		}
		
		let prevCard = {
			uid: '',
			sprite: null,
			process: false
		}
		
		/*
		* 当点击动作开始之后，必须在一次对比完成之后才能进行下一次操作
		* 对比正确 -> 进入下一次
		* 对比错误 -> 等待1s之后，重新翻转后，可进行下一次对比
		* 对比期间，禁用操作
		* */
		
		flipInterval = setTimeout(() => {
			for (let i = 0; i < currentCards.length; i++) {
				const flipBack = new TWEEN.Tween(scale)
				.to({
					x: -0.8
				}, 400)
				.onUpdate(result => {
					currentCards[i].sprite.scale.set(result.x, 0.8, 0.8)
					if (result.x < 0) {
						currentCards[i].sprite.texture = cardBack
					}
				})
				.onComplete(() => {
					currentCards[i].sprite.interactive = true
					currentCards[i].sprite.buttonMode = true
					currentCards[i].sprite.on('pointerdown', e => {
						if (prevCard.process || !e.target) return
						prevCard.process = true
						currentCards[i].process = true
						let target = e.target
						currentCards[i].sprite.interactive = false
						currentCards[i].sprite.buttonMode = false
						flipSound.play()
						
						// 点击翻转
						new TWEEN.Tween(currentCards[i].sprite.scale)
						.to({
							x: 0.8
						}, 400)
						.onUpdate(result => {
							currentCards[i].sprite.scale.set(result.x, 0.8, 0.8)
							if (result.x > 0) {
								currentCards[i].sprite.texture = currentCards[i].texture
							}
						})
						.onComplete(() => {
							if (prevCard.uid === '') {
								prevCard = {
									uid: target.name,
									sprite: currentCards[i].sprite,
									process: false
								}
							} else {
								if (prevCard.uid !== target.name) {
									// 点击卡片不正确后，0.5s后翻转，可重新选取card
									errorSound.play()
									setTimeout(() => {
										new TWEEN.Tween(currentCards[i].sprite.scale)
										.to({
											x: -0.8
										}, 400)
										.onUpdate(result => {
											currentCards[i].sprite.scale.set(result.x, 0.8, 0.8)
											prevCard.sprite.scale.set(result.x, 0.8, 0.8)
											if (result.x < 0) {
												currentCards[i].sprite.texture = cardBack
												prevCard.sprite.texture = cardBack
											}
										})
										.onComplete(() => {
											currentCards[i].sprite.interactive = true
											currentCards[i].sprite.buttonMode = true
											
											prevCard.sprite.interactive = true
											prevCard.sprite.buttonMode = true
											currentCards[i].process = false
											prevCard = {
												uid: '',
												sprite: null,
												process: false
											}
										})
										.start()
									}, 2000)
								} else {
									correctAnswerNum += 2
									successSound.play()
									if (correctAnswerNum === currentCards.length) {
										level++
										renderGameLogic()
									}
									prevCard = {
										uid: '',
										sprite: null,
										process: false
									}
									currentCards[i].process = false
								}
							}
						})
						.start()
					})
				})
				flipBack.start()
			}
		}, level < 2 ? lowLevelFlipTime : highLevelFlipTime)
		
		cardGroup.x = app.screen.width / 2
		cardGroup.y = app.screen.height / 2
		
		cardGroup.pivot.x = cardGroup.width / 2
		cardGroup.pivot.y = cardGroup.height / 2
		gameScene.addChild(cardGroup)
		
	}
	
	// 游戏开始倒计时
	function renderCount (sprites) {
		const three = sprites[2]
		const two = sprites[1]
		const one = sprites[0]
		
		const countAnimate = (obj, callback) => {
			console.log(obj, 'countAnimate')
			obj.visible = true
			const scales = {x: obj.scale.x, y: obj.scale.y}
			const tween = new TWEEN.Tween(scales)
			
			tween.to({
				x: 0.5,
				y: 0.5
			}, countTime)
			.onUpdate(result => {
				obj.scale.set(result.x, result.y)
			})
			.onComplete(() => {
				app.stage.removeChild(obj)
				callback && callback()
			})
			return tween
		}
		const threeStart = countAnimate(three)
		const twoStart = countAnimate(two)
		const oneStart = countAnimate(one, () => {
			renderGameLogic()
			renderToolbar(400)
			TWEEN.remove(threeStart)
			TWEEN.remove(twoStart)
			TWEEN.remove(oneStart)
		})
		
		threeStart.chain(twoStart)
		twoStart.chain(oneStart)
		
		threeStart.start()
	}
	
	// 游戏计时及计分
	function renderToolbar (remains) {
		const toolbars = new PIXI.Container()
		const statue = new PIXI.Graphics()
		let time = remains
		let remainTime = null
		statue.beginFill(0X000000, 0.5)
		statue.drawRect(0, 0, centerX * 2, 40)
		statue.endFill()
		toolbars.addChild(statue)
		let textStyle = new PIXI.TextStyle({
			fontFamily: 'PingFang SC Regular',
			fontSize: 18,
			fill: '#FFFFFF',
			stroke: '#cd0000',
			align: 'center',
			lineHeight: 40,
			textBaseline: 'middle'
		})
		gameScene.addChild(toolbars)
		
		const renderText = () => {
			remainTime = new PIXI.Text(`Remaining time: 00:${zeroFill(time)}`, textStyle)
			remainTime.resolution = 2
			remainTime.x = centerX - remainTime.width / 2
			remainTime.y = 5
			toolbars.addChild(remainTime)
		}
		
		renderText()
		
		counterInterval = setInterval(() => {
			remainTime && toolbars.removeChild(remainTime)
			if (time === 0) {
				gameOverHandler()
			}
			if (time > 0) {
				time--
			}
			renderText()
		}, 1000)
	}
	
	// 游戏结束逻辑
	function gameOverHandler () {
		clearInterval(counterInterval)
		const tween = new TWEEN.Tween(gameScene.position)
		.to({
			x: centerX * 2
		})
		.onUpdate(result => {
			gameScene.x = result.x
		})
		.onComplete(() => {
			app.stage.removeChild(gameScene)
			const gameOverText = new PIXI.Text('GAME OVER', {
				fontSize: 48,
				fill: 0XEA432B,
				fontWeight: 800
			})
			const alpha = {
				val: 0
			}
			gameOverText.y = centerY - gameOverText.height / 2
			gameOverText.x = centerX - gameOverText.width / 2
			gameOverText.alpha = alpha.val
			app.stage.addChild(gameOverText)
			
			const alphaTween = new TWEEN.Tween(alpha)
			.to({
				val: 1
			})
			.onUpdate(result => {
				gameOverText.alpha = result.val
			})
			alphaTween.start()
		})
		tween.start()
	}
	
	// 初始化多个游戏场景, start -> introduce -> ready
	function setup () {
		initSound()
		textureCache = PIXI.utils.TextureCache
		const {
			welcome,
			playBtn,
			intro,
			gameBackground,
			counts,
			correctImg,
			failImg
		} = textureCache
		
		// 游戏元素
		
		welcomeScene = new Sprite(new Texture(welcome))
		introScene = new Sprite(new Texture(intro))
		
		welcomeScene.x = transform.x
		introScene.x = introTransform.posX
		
		playBtnTexture = new Texture(playBtn)
		playBtnTexture.frame = new PIXI.Rectangle(0, 0, 200, 53)
		
		playBtnActiveTexture = new Texture(playBtn)
		playBtnActiveTexture.frame = new PIXI.Rectangle(0, 53, 200, 53)
		
		playButton = new Sprite(playBtnTexture)
		playButton.x = (centerX * 2 - playButton.width) / 2
		playButton.y = centerY * 2 - 80
		
		playButton.interactive = true
		playButton.buttonMode = true
		
		playButton.on('pointerdown', playHandler)
		playButton.on('pointerup', playUpHandler)
		
		app.stage.addChild(welcomeScene)
		app.stage.addChild(introScene)
		app.stage.addChild(playButton)
		
		// gameContent
		let gameBg = new Sprite(new Texture(gameBackground))
		
		gameScene = new PIXI.Container()
		gameScene.x = gameTransform.x
		gameScene.addChild(gameBg)
		app.stage.addChild(gameScene)
		
		const countOneTexture = new PIXI.Texture(counts)
		countOneTexture.frame = new PIXI.Rectangle(0, 0, 200, 200)
		countOne = new Sprite(countOneTexture)
		countSet.push(countOne)
		
		const countTwoTexture = new PIXI.Texture(counts)
		countTwoTexture.frame = new PIXI.Rectangle(200, 0, 200, 200)
		countTwo = new Sprite(countTwoTexture)
		countSet.push(countTwo)
		
		const countThreeTexture = new PIXI.Texture(counts)
		countThreeTexture.frame = new PIXI.Rectangle(400, 0, 200, 200)
		countThree = new Sprite(countThreeTexture)
		countSet.push(countThree)
		
		for (let item of countSet) {
			item.anchor.set(0.5, 0.5)
			item.scale.set(0.3)
			item.x = centerX
			item.y = centerY
			item.visible = false
			app.stage.addChild(item)
		}
		
		// correct fail hint
		correctBtn = new Sprite(new PIXI.Texture(correctImg))
		correctBtn.anchor.set(0.5)
		correctBtn.y = centerY - correctBtn.height / 2
		correctBtn.x = 80
		correctBtn.scale.set(0.5)
		correctBtn.alpha = 0
		
		failBtn = new Sprite(new PIXI.Texture(failImg))
		failBtn.anchor.set(0.5)
		failBtn.y = centerY - correctBtn.height / 2
		failBtn.x = 80
		failBtn.scale.set(0.5)
		failBtn.alpha = 0
		
		app.stage.addChild(correctBtn)
		app.stage.addChild(failBtn)
	}
	
	function playHandler (e) {
		e.stopPropagation()
		let self = this
		clickSound.play()
		self.texture = playBtnActiveTexture
		if (currentScene === 0) {
			const tween = new TWEEN.Tween(transform)
			.to({
				x: centerX * 2
			}, 500)
			.onUpdate(updateScene1Handler)
			.onComplete(() => {
				currentScene = 1
			})
			
			const introSceneTween = new TWEEN.Tween(introTransform)
			.to({
				posX: 0
			}, 500)
			.onUpdate(updateScene2Handler)
			
			tween.start()
			introSceneTween.start()
			
			function updateScene1Handler (object) {
				welcomeScene.x = object.x
			}
			
			function updateScene2Handler (object) {
				introScene.x = object.posX
			}
		}
		if (currentScene === 1) {
			self.alpha = 0
			const tween = new TWEEN.Tween(gameTransform)
			.to({
				x: 0
			}, 500)
			.onUpdate(obj => {
				gameScene.x = obj.x
			})
			const introTrans = new TWEEN.Tween(introTransform)
			.to({
				posX: centerX * 2
			}, 500)
			.onUpdate(obj => {
				introScene.x = obj.posX
			})
			.onComplete(() => {
				app.stage.removeChild(playButton)
				renderCount(countSet)
			})
			
			tween.start()
			introTrans.start()
		}
	}
	
	function playUpHandler (e) {
		e.stopPropagation()
		this.texture = playBtnTexture
	}
	
	animate()
	
	function animate () {
		requestAnimationFrame(animate)
		TWEEN.update()
	}

</script>
</body>
</html>
