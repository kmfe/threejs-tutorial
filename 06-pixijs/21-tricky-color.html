<!doctype html>
<html lang='en'>
<head>
  <meta charset='UTF-8'>
  <meta name='viewport'
    content='width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0'>
  <meta http-equiv='X-UA-Compatible' content='ie=edge'>
  <title>pixi.js tutorial</title>
  <script src='./lib/tween.umd.js'></script>
  <script src='./lib/pixi.js'></script>
  <script src='./lib/pixi-sound.js'></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
      'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
      'Noto Color Emoji';
    }
    
    ul, li {
      list-style: none;
    }
    
    html, body {
    }
    
    .playground canvas {
      display: block;
      margin: 0 auto;
    }
    
    .game-title {
      text-align: center;
      font-size: 24px;
      line-height: 2;
    }
    
    .game-info {
      margin: 30px auto;
      width: 80%;
      line-height: 1.2;
    }
    
    .game-info section {
      margin-bottom: 20px;
    }
    
    .game-info__title {
      margin-bottom: 10px;
    }
    
    .mb10 {
      padding: 10px 0;
      margin-bottom: 10px;
      border-bottom: 1px solid #ccc;
    }
  </style>
</head>
<body>
<h1 class='game-title'>Tricky Color</h1>
<div class='playground'></div>
<div class='game-info'>
  <section>
    <h3 class='game-info__title'>Training focus</h3>
    <div class='game-info__desc'>
      <ul>
        <li> Attention selectivity</li>
        <li> Attention span</li>
        <li> Executive functions</li>
        <li> Speed</li>
      </ul>
    </div>
  </section>
  <section>
    <h3 class='game-info__title'>Principles of the training</h3>
    <div class='game-info__desc'>
      <ul>
        <li>
          The game trains the attention distribution and attention selectivity. Continuous control of the accuracy of
          responses trains executive functions. Working in a time limit improves the response speed.
        </li>
        <li>
          Sneaky colors show how easily we can get distracted by our automatic reactions and habits. The game is based
          on the discrepancy between two pieces of visual information (perceptions). The first one is the text, the
          other one is the color. Both reach the brain at the same time, but the processing time varies. The brain first
          processes text information.
        </li>
        <li>
          The game integrates the so-called Stroop test principle, which is one of the basic psychodiagnostic tools. It
          detects the level of executive functions, the ability to handle conflicts and the degree of attention.
        </li>
      </ul>
    </div>
  </section>
  <section>
    <h3 class='game-info__title'>How to play this game</h3>
    <div class='game-info__desc'>
      <p class='mb10'>
        The game has three levels of difficulty. At the easiest level (only one tin), the player must determine if the
        color of the text corresponds to the meaning of the text.
      </p>
      <p class='mb10'>
        At the second level (2 tins), the player’s task is to decide if the color of the text on the right tin
        corresponds to the meaning of the text on the left tin, see the picture for explanation:
        <img src='./assets/tricky-color/chytni_barvu_correct.png' alt=''>
      </p>
      <p>
        On the left tin, the word “yellow” is written while the text on the right tin is of yellow color. The correct
        solution is YES.
        
        <img src='./assets/tricky-color/chytni_barvu_incorrect.png' alt=''>
      </p>
      <p>
        The word on the right tin is not written in yellow color, therefore the correct answer is NO.
        In addition to that, at the hardest level (2 tins), every answer has a time limit, thus the player must answer
        within 2 seconds.
      </p>
    </div>
  </section>
</div>
<script>
	const options = {
		width: 615,
		height: 505,
		transparent: false,
		backgroundColor: 0XEEEEEE
	}
	const app = new PIXI.Application(options)
	let clickSound, successSound, errorSound, flipSound, explosionSound
	const countTime = 1000
	let angle = 30
	
	function initSound () {
		// 声音
		const manifest = {
			success: './assets/sound/success.mp3',
			click: './assets/sound/click.mp3',
			error: './assets/sound/error.mp3',
			levelwon: './assets/sound/levelwon.mp3',
			flip: './assets/sound/flip.mp3',
			explosion: './assets/sound/explosion.mp3'
		}
		
		// add to PIXI loader
		PIXI.sound.volumeAll = 100
		for (let resource in manifest) {
			PIXI.Loader.shared.add(resource, manifest[resource])
		}
		// preload the sounds
		PIXI.Loader.shared.load(function (loader, resources) {
			clickSound = resources['click'].sound
			successSound = resources['success'].sound
			errorSound = resources['error'].sound
			flipSound = resources['flip'].sound
			explosionSound = resources['explosion'].sound
		})
	}
	
	const playground = document.querySelector('.playground')
	playground.appendChild(app.view)
	
	const centerX = app.renderer.view.width / 2
	const centerY = app.renderer.view.height / 2
	const loader = new PIXI.Loader()
	const Sprite = PIXI.Sprite
	const Texture = PIXI.Texture
	
	let currentScene = 0
	
	let playBtnActiveTexture, playBtnTexture, playButton,
		welcomeScene, introScene, gameScene,
		correctBtn, failBtn,
		countOne, countTwo, countThree, counterInterval, countSet = [],
		textureCache,
		level = 2
	
	// welcome, introduce scene animate params
	let transform = {
		x: 0
	}
	let introTransform = {
		posX: -centerX * 2
	}
	let gameTransform = {
		x: -centerX * 2
	}
	
	const rightPanelWidth = 194
	
	// 加载图片转化成纹理
	loader
	.add('welcome', './assets/tricky-color/en/title_screen.png')
	.add('intro', './assets/tricky-color/en/instructions.png')
	
	.add('correctImg', './assets/tricky-color/common/sign_ok.png')
	.add('failImg', './assets/tricky-color/common/sign_fail.png')
	
	.add('yesBtn', './assets/tricky-color/en/button_right.png')
	.add('noBtn', './assets/tricky-color/en/button_left.png')
	.add('bubble', './assets/tricky-color/common/bubble_small.png')
	
	.add('gameBackground', './assets/tricky-color/common/gameBackground.png')
	.add('playBtn', './assets/tricky-color/en/button_play.png')
	.add('counts', './assets/tricky-color/common/counts.png')
	.load(setup)
	
	// 补零
	function zeroFill (num) {
		return num < 10 ? '0' + num : num
	}
	
	// 不包含最大值，用于在取数组中任意数
	function getRangeNum (min, max) {
		return Math.floor(Math.random() * (max - min)) + min
	}
	
	// 游戏业务代码
	// 生成computedItem，键盘输入 或 右侧模拟数字键盘输入后 enter 键，检测答案正确性
	// 生成当前游戏状态，remain lives以及当前level
	
	let correctAnswer = null, bubbleBtn, ctrls = [], text
	
	const colors = [
		{key: 'yellow', value: '#FFFF00'},
		{key: 'green', value: '#00FF00'},
		{key: 'black', value: '#000000'},
		{key: 'orange', value: '#FFA500'},
		{key: 'red', value: '#FF0000'},
		{key: 'gray', value: '#BEBEBE'},
		{key: 'purple', value: '#9B30FF'}
	]
	const texts = ['yellow', 'green', 'black', 'orange', 'red', 'gray', 'purple']
	
	function renderGameLogic () {
		if (text) gameScene.removeChild(text)
		// 添加测试问题
		const colorIndex = getRangeNum(0, colors.length)
		const textIndex = getRangeNum(0, texts.length)
		
		const textStyle = {
			fontSize: 28,
			fill: colors[colorIndex].value,
			stroke: '#000000',
			strokeThickness: 1,
			letterSpacing: 1
		}
		
		text = new PIXI.Text(texts[textIndex], textStyle)
		text.anchor.set(0.5)
		text.x = centerX + 130
		text.y = centerY + 16
		gameScene.addChild(text)
		correctAnswer = colors[colorIndex].key === texts[textIndex]
		
		// 添加 textTip Bubble
		function renderBubble () {
			const bubbleBtn = new Sprite(textureCache['bubble'])
			bubbleBtn.anchor.set(0.5)
			bubbleBtn.x = centerX + 130
			bubbleBtn.y = centerY - 124
			const bubbleText = new PIXI.Text('text color', {fontSize: 20, fill: '#000'})
			bubbleText.anchor.set(0.5)
			bubbleText.y = -2
			bubbleBtn.addChild(bubbleText)
			gameScene.addChild(bubbleBtn)
		}
		
		if (!bubbleBtn) renderBubble()
		
		// 添加操作按钮
		function addCtrl () {
			const yesBtnTexture = textureCache['yesBtn']
			yesBtnTexture.frame = new PIXI.Rectangle(0, 0, 202, 59)
			const yesBtn = new Sprite(yesBtnTexture)
			
			const yesBtnActiveTexture = new Texture(textureCache['yesBtn'])
			yesBtnActiveTexture.frame = new PIXI.Rectangle(0, 59, 202, 59)
			
			const noBtnTexture = textureCache['noBtn']
			noBtnTexture.frame = new PIXI.Rectangle(0, 0, 202, 59)
			const noBtn = new Sprite(noBtnTexture)
			
			const noBtnActiveTexture = new Texture(textureCache['noBtn'])
			noBtnActiveTexture.frame = new PIXI.Rectangle(0, 59, 202, 59)
			
			gameScene.addChild(yesBtn)
			gameScene.addChild(noBtn)
			
			ctrls = [yesBtn, noBtn]
			for (let i = 0; i < ctrls.length; i++) {
				ctrls[i].anchor.set(0.5)
				ctrls[i].scale.set(0.8)
				ctrls[i].interactive = true
				ctrls[i].buttonMode = true
				ctrls[i].y = centerY * 2 - 50
				
				if (i === 0) {
					ctrls[i].x = centerX * 2 - 180
				} else {
					ctrls[i].x = 180
				}
				
				ctrls[i].on('pointerover', () => {
					if (i === 0) {
						ctrls[i].texture = yesBtnActiveTexture
					} else {
						ctrls[i].texture = noBtnActiveTexture
					}
				})
				
				ctrls[i].on('pointerout', () => {
					if (i === 0) {
						ctrls[i].texture = yesBtnTexture
					} else {
						ctrls[i].texture = noBtnTexture
					}
				})
				
				ctrls[i].on('pointerdown', () => {
					if (i === 0) {
						checkHint(correctAnswer)
					} else {
						checkHint(!correctAnswer)
					}
					renderGameLogic()
				})
			}
		}
		
		if (!ctrls.length) addCtrl()
	}
	
	// 游戏计时及计分
	function renderToolbar (remains) {
		const toolbars = new PIXI.Container()
		const statue = new PIXI.Graphics()
		let time = remains
		let remainTime = null
		statue.beginFill(0X000000, 0.5)
		statue.drawRect(0, 0, centerX * 2, 40)
		statue.endFill()
		toolbars.addChild(statue)
		let textStyle = new PIXI.TextStyle({
			fontFamily: 'PingFang SC Regular',
			fontSize: 18,
			fill: '#FFFFFF',
			stroke: '#cd0000',
			align: 'center',
			lineHeight: 40,
			textBaseline: 'middle'
		})
		toolbars.zIndex = 3
		gameScene.addChild(toolbars)
		
		const renderText = () => {
			remainTime = new PIXI.Text(`Remaining time: 00:${zeroFill(time)}`, textStyle)
			remainTime.resolution = 2
			remainTime.x = centerX - remainTime.width / 2
			remainTime.y = 5
			toolbars.addChild(remainTime)
		}
		
		renderText()
		
		counterInterval = setInterval(() => {
			remainTime && toolbars.removeChild(remainTime)
			if (time === 0) {
				gameOverHandler()
			}
			if (time > 0) {
				time--
			}
			renderText()
		}, 1000)
	}
	
	// 游戏开始倒计时
	function renderCount (sprites) {
		const three = sprites[2]
		const two = sprites[1]
		const one = sprites[0]
		
		const countAnimate = (obj, callback) => {
			obj.visible = true
			const scales = {x: obj.scale.x, y: obj.scale.y}
			const tween = new TWEEN.Tween(scales)
			
			tween.to({
				x: 0.5,
				y: 0.5
			}, countTime)
			.onUpdate(result => {
				obj.scale.set(result.x, result.y)
			})
			.onComplete(() => {
				app.stage.removeChild(obj)
				callback && callback()
			})
			return tween
		}
		const threeStart = countAnimate(three)
		const twoStart = countAnimate(two)
		const oneStart = countAnimate(one, () => {
			renderGameLogic()
			renderToolbar(400)
			TWEEN.remove(threeStart)
			TWEEN.remove(twoStart)
			TWEEN.remove(oneStart)
		})
		
		threeStart.chain(twoStart)
		twoStart.chain(oneStart)
		
		threeStart.start()
	}
	
	// 错误正确判断 及计数
	function checkHint (isRight) {
		const hint = sprite => {
			const transform = {
				alpha: sprite.alpha,
				x: sprite.scale.x,
				y: sprite.scale.y
			}
			let tween = new TWEEN.Tween(transform)
			.to({
				x: 0.8,
				y: 0.8,
				alpha: 1
			}, 200)
			.onUpdate(result => {
				sprite.scale.set(result.x, result.y)
				sprite.alpha = result.alpha
			})
			.onComplete(() => {
				sprite.alpha = 0
				sprite.scale.set(0.4, 0.4)
			})
			tween.start()
		}
		if (isRight) {
			hint(correctBtn)
			successSound.play()
		} else {
			hint(failBtn)
			errorSound.play()
		}
	}
	
	// 游戏结束逻辑
	function gameOverHandler () {
		clearInterval(counterInterval)
		const tween = new TWEEN.Tween(gameScene.position)
		.to({
			x: centerX * 2
		})
		.onUpdate(result => {
			gameScene.x = result.x
		})
		.onComplete(() => {
			app.stage.removeChild(gameScene)
			const gameOverText = new PIXI.Text('GAME OVER', {
				fontSize: 48,
				fill: 0XEA432B,
				fontWeight: 800
			})
			const alpha = {
				val: 0
			}
			gameOverText.y = centerY - gameOverText.height / 2
			gameOverText.x = centerX - gameOverText.width / 2
			gameOverText.alpha = alpha.val
			app.stage.addChild(gameOverText)
			
			const alphaTween = new TWEEN.Tween(alpha)
			.to({
				val: 1
			})
			.onUpdate(result => {
				gameOverText.alpha = result.val
			})
			alphaTween.start()
		})
		tween.start()
	}
	
	// 初始化多个游戏场景, start -> introduce -> ready
	function setup () {
		initSound()
		textureCache = PIXI.utils.TextureCache
		const {
			welcome,
			playBtn,
			intro,
			gameBackground,
			counts,
			correctImg,
			failImg
		} = textureCache
		
		// 游戏元素
		
		welcomeScene = new Sprite(new Texture(welcome))
		introScene = new Sprite(new Texture(intro))
		
		welcomeScene.x = transform.x
		introScene.x = introTransform.posX
		
		playBtnTexture = new Texture(playBtn)
		playBtnTexture.frame = new PIXI.Rectangle(0, 0, 202, 59)
		
		playBtnActiveTexture = new Texture(playBtn)
		playBtnActiveTexture.frame = new PIXI.Rectangle(0, 59, 202, 59)
		
		playButton = new Sprite(playBtnTexture)
		playButton.x = (centerX * 2 - playButton.width) / 2
		playButton.y = centerY * 2 - 80
		
		playButton.interactive = true
		playButton.buttonMode = true
		
		playButton.on('pointerdown', playHandler)
		playButton.on('pointerup', playUpHandler)
		
		app.stage.addChild(welcomeScene)
		app.stage.addChild(introScene)
		app.stage.addChild(playButton)
		
		// gameContent
		let gameBg = new Sprite(new Texture(gameBackground))
		
		gameScene = new PIXI.Container()
		gameScene.x = gameTransform.x
		gameScene.addChild(gameBg)
		app.stage.addChild(gameScene)
		
		const countOneTexture = new PIXI.Texture(counts)
		countOneTexture.frame = new PIXI.Rectangle(0, 0, 200, 200)
		countOne = new Sprite(countOneTexture)
		countSet.push(countOne)
		
		const countTwoTexture = new PIXI.Texture(counts)
		countTwoTexture.frame = new PIXI.Rectangle(200, 0, 200, 200)
		countTwo = new Sprite(countTwoTexture)
		countSet.push(countTwo)
		
		const countThreeTexture = new PIXI.Texture(counts)
		countThreeTexture.frame = new PIXI.Rectangle(400, 0, 200, 200)
		countThree = new Sprite(countThreeTexture)
		countSet.push(countThree)
		
		for (let item of countSet) {
			item.anchor.set(0.5, 0.5)
			item.scale.set(0.3)
			item.x = centerX
			item.y = centerY
			item.visible = false
			app.stage.addChild(item)
		}
		
		// correct fail hint
		correctBtn = new Sprite(new PIXI.Texture(correctImg))
		correctBtn.anchor.set(0.5)
		correctBtn.y = centerY - 72
		correctBtn.x = centerX
		correctBtn.scale.set(0.5)
		correctBtn.alpha = 0
		
		failBtn = new Sprite(new PIXI.Texture(failImg))
		failBtn.anchor.set(0.5)
		failBtn.y = centerY - 72
		failBtn.x = centerX
		failBtn.scale.set(0.5)
		failBtn.alpha = 0
		
		app.stage.addChild(correctBtn)
		app.stage.addChild(failBtn)
	}
	
	function playHandler (e) {
		e.stopPropagation()
		let self = this
		clickSound.play()
		self.texture = playBtnActiveTexture
		if (currentScene === 0) {
			const tween = new TWEEN.Tween(transform)
			.to({
				x: centerX * 2
			}, 500)
			.onUpdate(updateScene1Handler)
			.onComplete(() => {
				currentScene = 1
			})
			
			const introSceneTween = new TWEEN.Tween(introTransform)
			.to({
				posX: 0
			}, 500)
			.onUpdate(updateScene2Handler)
			
			tween.start()
			introSceneTween.start()
			
			function updateScene1Handler (object) {
				welcomeScene.x = object.x
			}
			
			function updateScene2Handler (object) {
				introScene.x = object.posX
			}
		}
		if (currentScene === 1) {
			self.alpha = 0
			const tween = new TWEEN.Tween(gameTransform)
			.to({
				x: 0
			}, 500)
			.onUpdate(obj => {
				gameScene.x = obj.x
			})
			
			const introTrans = new TWEEN.Tween(introTransform)
			.to({
				posX: centerX * 2
			}, 500)
			.onUpdate(obj => {
				introScene.x = obj.posX
			})
			.onComplete(() => {
				app.stage.removeChild(playButton)
				renderCount(countSet)
			})
			
			tween.start()
			introTrans.start()
		}
	}
	
	function playUpHandler (e) {
		e.stopPropagation()
		this.texture = playBtnTexture
	}
	
	animate()
	
	function animate () {
		requestAnimationFrame(animate)
		TWEEN.update()
	}

</script>
</body>
</html>
