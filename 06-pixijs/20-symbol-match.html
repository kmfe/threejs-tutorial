<!doctype html>
<html lang='en'>
<head>
  <meta charset='UTF-8'>
  <meta name='viewport'
    content='width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0'>
  <meta http-equiv='X-UA-Compatible' content='ie=edge'>
  <title>pixi.js tutorial</title>
  <script src='./lib/tween.umd.js'></script>
  <script src='./lib/pixi.js'></script>
  <script src='./lib/pixi-sound.js'></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
      'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
      'Noto Color Emoji';
    }
    
    ul, li {
      list-style: none;
    }
    
    html, body {
    }
    
    .playground canvas {
      display: block;
      margin: 0 auto;
    }
    
    .game-title {
      text-align: center;
      font-size: 24px;
      line-height: 2;
    }
    
    .game-info {
      margin: 30px auto;
      width: 80%;
      line-height: 1.2;
    }
    
    .game-info section {
      margin-bottom: 20px;
    }
    
    .game-info__title {
      margin-bottom: 10px;
    }
    
    .mb10 {
      padding: 10px 0;
      margin-bottom: 10px;
      border-bottom: 1px solid #ccc;
    }
  </style>
</head>
<body>
<h1 class='game-title'>Identify Similar == Symbol match</h1>
<div class='playground'></div>
<div class='game-info'>
  <section>
    <h3 class='game-info__title'>Training focus</h3>
    <div class='game-info__desc'>
      <ul>
        <li>Ultrashort-term memory</li>
        <li>Attention span</li>
        <li>Speed</li>
      </ul>
    </div>
  </section>
  <section>
    <h3 class='game-info__title'>Principles of the training</h3>
    <div class='game-info__desc'>
      <ul>
        <li>
          The game practices an ultra-short-term memory because it involves storing previous images in mind. Determining
          whether the previous object is identical with the new one requires a high degree of attention and its
          switching.
        </li>
        <li>
          The game also develops the ability to differentiate various stimuli by color and shape as well as it improves
          the decision speed.
        </li>
        <li>
          Working in a time limit helps the growth of response speed.
        </li>
      </ul>
    </div>
  </section>
  <section>
    <h3 class='game-info__title'>How to play this game</h3>
    <div class='game-info__desc'>
      <p class='mb10'>
        Goal of this game is to identify the resemblance of the shapes and colors of two objects in the shortest
        possible time.
        At the beginning of the game you will see the first object. After hitting the button PLAY, it will disappear and
        a second one will be shown. If the second picture looks the same as the first one, press the left arrow.
        Your task is to compare a displayed symbol with the one that has just disappeared.
      </p>
    </div>
  </section>
</div>
<script>
	const options = {
		width: 615,
		height: 505,
		transparent: false,
		backgroundColor: 0XEEEEEE
	}
	const app = new PIXI.Application(options)
	let clickSound, successSound, errorSound, flipSound, explosionSound
	const countTime = 1000
	let angle = 30
	
	function initSound () {
		// 声音
		const manifest = {
			success: './assets/sound/success.mp3',
			click: './assets/sound/click.mp3',
			error: './assets/sound/error.mp3',
			levelwon: './assets/sound/levelwon.mp3',
			flip: './assets/sound/flip.mp3',
			explosion: './assets/sound/explosion.mp3'
		}
		
		// add to PIXI loader
		PIXI.sound.volumeAll = 100
		for (let resource in manifest) {
			PIXI.Loader.shared.add(resource, manifest[resource])
		}
		// preload the sounds
		PIXI.Loader.shared.load(function (loader, resources) {
			clickSound = resources['click'].sound
			successSound = resources['success'].sound
			errorSound = resources['error'].sound
			flipSound = resources['flip'].sound
			explosionSound = resources['explosion'].sound
		})
	}
	
	const playground = document.querySelector('.playground')
	playground.appendChild(app.view)
	
	const centerX = app.renderer.view.width / 2
	const centerY = app.renderer.view.height / 2
	const loader = new PIXI.Loader()
	const Sprite = PIXI.Sprite
	const Texture = PIXI.Texture
	
	let currentScene = 0
	
	let playBtnActiveTexture, playBtnTexture, playButton,
		welcomeScene, introScene, gameScene,
		correctBtn, failBtn,
		countOne, countTwo, countThree, counterInterval, countSet = [],
		textureCache,
		level = 2
	
	let symbolBg, matchBtns = [], currentSymbol, nextSymbol, isMatch
	
	// 加载图片转化成纹理
	loader
	.add('welcome', './assets/symbol-match/en/title_screen.png')
	.add('intro', './assets/symbol-match/en/instructions.png')
	.add('correctImg', './assets/symbol-match/common/sign_ok.png')
	.add('failImg', './assets/symbol-match/common/sign_fail.png')
	
	.add('colorSymbols', './assets/symbol-match/common/symbols_stars.png')
	.add('shapeSymbolsSmall', './assets/symbol-match/common/symbols_small.png')
	.add('symbolBackground', './assets/symbol-match/common/symbolBackground.png')
	.add('gameBackground', './assets/symbol-match/common/gameBackground.png')
	.add('arrow', './assets/symbol-match/common/arrowRight.png')
	
	.add('playBtn', './assets/symbol-match/en/button_play.png')
	.add('counts', './assets/symbol-match/common/counts.png')
	.load(setup)
	
	// 补零
	function zeroFill (num) {
		return num < 10 ? '0' + num : num
	}
	
	// 不包含最大值，用于在取数组中任意数
	function getRangeNum (min, max) {
		return Math.floor(Math.random() * (max - min)) + min
	}
	
	// 游戏业务代码
	// 生成computedItem，键盘输入 或 右侧模拟数字键盘输入后 enter 键，检测答案正确性
	// 生成当前游戏状态，remain lives以及当前level
	
	function renderGameLogic () {
		// 第一次渲染，需要加上些描述，不渲染是否match按钮
		const tipText = new PIXI.Text('Remember the symbol', {
			fontSize: 16
		})
		tipText.zIndex = 3
		tipText.anchor.set(0.5)
		tipText.x = centerX
		tipText.y = centerY * 2 - 80
		tipText.alpha = 0
		
		new TWEEN.Tween({alpha: tipText.alpha})
		.to({alpha: 1}, 200)
		.onUpdate(result => {tipText.alpha = result.alpha})
		.start()
		gameScene.addChild(tipText)
		
		// 生成symbol 方法
		const types = [textureCache['colorSymbols'], textureCache['shapeSymbolsSmall']]
		const typeIndex = getRangeNum(0, types.length)
		const renderSymbol = (isFirst = false) => {
			let symbols = []
			for (let i = 0; i < 6; i++) {
				let texture = new Texture(types[typeIndex])
				texture.frame = new PIXI.Rectangle((i % 3) * 189, i >= 3 ? 163 : 0, 189, 163);
				let sprite = new Sprite(texture)
				sprite.name = 'index-' + i
				sprite.zIndex = 2
				symbols.push({
					sprite,
					name: sprite.name
				})
			}
			const currentSprite = symbols[getRangeNum(0, symbols.length)].sprite
			currentSprite.anchor.set(0.5)
			currentSprite.x = isFirst ? centerX : centerX + 260
			currentSprite.y = centerY - 20
			gameScene.addChild(currentSprite)
			return currentSprite
		}
		
		currentSymbol = renderSymbol(true)
		
		// 循环生成symbols
		let animating = false
		const renderSymbolsCycle = () => {
			if (animating) return
			animating = true
			// 移除前一个symbol
			new TWEEN.Tween(currentSymbol.position)
			.to({x: 0}, 200)
			.onUpdate(result => {currentSymbol.x = result.x})
			.onComplete(() => {
				playButton && app.stage.removeChild(playButton)
				if (!matchBtns.length) renderMatchBtns()
			})
			.start()
			
			// 生成下一个symbol
			nextSymbol = renderSymbol()
			isMatch = currentSymbol.name === nextSymbol.name
			new TWEEN.Tween(nextSymbol.position)
			.delay(100)
			.to({x: centerX}, 200)
			.onUpdate(result => {
				nextSymbol.x = result.x
			})
			.onComplete(() => {
				// 先移除前面的
				gameScene.removeChild(currentSymbol)
				currentSymbol.destroy()
				currentSymbol = null
				currentSymbol = nextSymbol
				animating = false
			})
			.start()
		}
		
		// 生成 match button
		const renderMatchBtns = () => {
			const matchTexture = new Texture(textureCache['arrow'])
			matchTexture.frame = new PIXI.Rectangle(0, 0, 50, 50)
			
			const matchActiveTexture = new Texture(textureCache['arrow'])
			matchActiveTexture.frame = new PIXI.Rectangle(50, 0, 50, 50)
			
			const notMatchBtn = new Sprite(matchTexture)
			notMatchBtn.zIndex = 3
			notMatchBtn.anchor.set(0.5)
			notMatchBtn.scale.set(-0.6, 0.6)
			notMatchBtn.x = 240
			notMatchBtn.y = centerY * 2 - 60
			
			const notMatchText = new PIXI.Text('Not the same', {fontSize: 20})
			notMatchText.anchor.set(0.5)
			notMatchText.x = 120
			notMatchText.scale.set(-1.2, 1.2)
			notMatchBtn.addChild(notMatchText)
			
			const matchBtn = new Sprite(matchTexture)
			matchBtn.zIndex = 3
			matchBtn.anchor.set(0.5)
			matchBtn.scale.set(0.6, 0.6)
			matchBtn.x = centerX * 2 - 240
			matchBtn.y = centerY * 2 - 60
			
			const matchText = new PIXI.Text('The same', {fontSize: 20})
			matchText.anchor.set(0.5)
			matchText.x = 100
			matchText.scale.set(1.2, 1.2)
			matchBtn.addChild(matchText)
			
			matchBtns = [matchBtn, notMatchBtn]
			
			for (let i = 0; i < matchBtns.length; i++) {
				matchBtns[i].interactive = true
				matchBtns[i].buttonMode = true
				matchBtns[i].on('pointerover', () => {
					matchBtns[i].texture = matchActiveTexture
				})
				matchBtns[i].on('pointerout', () => {
					matchBtns[i].texture = matchTexture
				})
				matchBtns[i].on('pointerdown', () => {
					if (isMatch) {
						if (i === 0) {
							checkHint(true)
						} else {
							checkHint(false)
						}
					} else {
						if (i !== 0) {
							checkHint(true)
						} else {
							checkHint(false)
						}
					}
					renderSymbolsCycle()
				})
				gameScene.addChild(matchBtns[i])
			}
		}
		
		// 后面的渲染
		playButton.on('pointerdown', () => {
			if (currentScene !== 3) return
			
			// 移除字符
			new TWEEN.Tween({alpha: tipText.alpha})
			.to({alpha: 0}, 400)
			.onUpdate(result => {tipText.alpha = result.alpha})
			.onComplete(() => {gameScene.removeChild(tipText)})
			.start()
			
			// 开始循环symbol
			renderSymbolsCycle()
		})
	}
	
	// 游戏开始倒计时
	function renderCount (sprites) {
		const three = sprites[2]
		const two = sprites[1]
		const one = sprites[0]
		
		const countAnimate = (obj, callback) => {
			obj.visible = true
			const scales = {x: obj.scale.x, y: obj.scale.y}
			const tween = new TWEEN.Tween(scales)
			
			tween.to({
				x: 0.5,
				y: 0.5
			}, countTime)
			.onUpdate(result => {
				obj.scale.set(result.x, result.y)
			})
			.onComplete(() => {
				app.stage.removeChild(obj)
				callback && callback()
			})
			return tween
		}
		const threeStart = countAnimate(three)
		const twoStart = countAnimate(two)
		const oneStart = countAnimate(one, () => {
			renderGameLogic()
			renderToolbar(400)
			TWEEN.remove(threeStart)
			TWEEN.remove(twoStart)
			TWEEN.remove(oneStart)
		})
		
		threeStart.chain(twoStart)
		twoStart.chain(oneStart)
		
		threeStart.start()
	}
	
	// 游戏计时及计分
	function renderToolbar (remains) {
		const toolbars = new PIXI.Container()
		const statue = new PIXI.Graphics()
		let time = remains
		let remainTime = null
		statue.beginFill(0X000000, 0.5)
		statue.drawRect(0, 0, centerX * 2, 40)
		statue.endFill()
		toolbars.addChild(statue)
		let textStyle = new PIXI.TextStyle({
			fontFamily: 'PingFang SC Regular',
			fontSize: 18,
			fill: '#FFFFFF',
			stroke: '#cd0000',
			align: 'center',
			lineHeight: 40,
			textBaseline: 'middle'
		})
		toolbars.zIndex = 3
		gameScene.addChild(toolbars)
		
		const renderText = () => {
			remainTime = new PIXI.Text(`Remaining time: 00:${zeroFill(time)}`, textStyle)
			remainTime.resolution = 2
			remainTime.x = centerX - remainTime.width / 2
			remainTime.y = 5
			toolbars.addChild(remainTime)
		}
		
		renderText()
		
		counterInterval = setInterval(() => {
			remainTime && toolbars.removeChild(remainTime)
			if (time === 0) {
				gameOverHandler()
			}
			if (time > 0) {
				time--
			}
			renderText()
		}, 1000)
	}
	
	// 游戏结束逻辑
	function gameOverHandler () {
		clearInterval(counterInterval)
		const tween = new TWEEN.Tween(gameScene.position)
		.to({
			x: centerX * 2
		})
		.onUpdate(result => {
			gameScene.x = result.x
		})
		.onComplete(() => {
			app.stage.removeChild(gameScene)
			const gameOverText = new PIXI.Text('GAME OVER', {
				fontSize: 48,
				fill: 0XEA432B,
				fontWeight: 800
			})
			const alpha = {
				val: 0
			}
			gameOverText.y = centerY - gameOverText.height / 2
			gameOverText.x = centerX - gameOverText.width / 2
			gameOverText.alpha = alpha.val
			app.stage.addChild(gameOverText)
			
			const alphaTween = new TWEEN.Tween(alpha)
			.to({
				val: 1
			})
			.onUpdate(result => {
				gameOverText.alpha = result.val
			})
			alphaTween.start()
		})
		tween.start()
	}
	
	// 错误正确判断 及计数
	function checkHint (isRight) {
		const hint = sprite => {
			const transform = {
				alpha: sprite.alpha,
				x: sprite.scale.x,
				y: sprite.scale.y
			}
			let tween = new TWEEN.Tween(transform)
			.to({
				x: 0.8,
				y: 0.8,
				alpha: 1
			}, 200)
			.onUpdate(result => {
				sprite.scale.set(result.x, result.y)
				sprite.alpha = result.alpha
			})
			.onComplete(() => {
				sprite.alpha = 0
				sprite.scale.set(0.4, 0.4)
			})
			tween.start()
		}
		if (isRight) {
			hint(correctBtn)
			successSound.play()
		} else {
			hint(failBtn)
			errorSound.play()
		}
	}
	
	// 初始化多个游戏场景, start -> introduce -> ready
	function setup () {
		initSound()
		textureCache = PIXI.utils.TextureCache
		const {
			welcome,
			playBtn,
			intro,
			gameBackground,
			symbolBackground,
			counts,
			correctImg,
			failImg
		} = textureCache
		
		// 游戏元素
		
		welcomeScene = new Sprite(new Texture(welcome))
		introScene = new Sprite(new Texture(intro))
		
		welcomeScene.x = 0
		introScene.x = -centerX * 2
		
		playBtnTexture = new Texture(playBtn)
		playBtnTexture.frame = new PIXI.Rectangle(0, 0, 202, 60)
		
		playBtnActiveTexture = new Texture(playBtn)
		playBtnActiveTexture.frame = new PIXI.Rectangle(0, 60, 202, 60)
		
		playButton = new Sprite(playBtnTexture)
		playButton.anchor.set(0.5)
		playButton.x = centerX
		playButton.y = centerY * 2 - 40
		
		playButton.interactive = true
		playButton.buttonMode = true
		
		playButton.on('pointerdown', playHandler)
		playButton.on('pointerup', playUpHandler)
		
		app.stage.addChild(welcomeScene)
		app.stage.addChild(introScene)
		
		// gameContent
		symbolBg = new Sprite(symbolBackground)
		symbolBg.zIndex = 1
		let gameBg = new Sprite(gameBackground)
		gameBg.zIndex = 3
		gameScene = new PIXI.Container()
		gameScene.sortableChildren = true
		
		gameScene.x = -centerX * 2
		gameScene.addChild(symbolBg)
		gameScene.addChild(gameBg)
		app.stage.addChild(gameScene)
		
		app.stage.addChild(playButton)
		
		const countOneTexture = new PIXI.Texture(counts)
		countOneTexture.frame = new PIXI.Rectangle(0, 0, 200, 200)
		countOne = new Sprite(countOneTexture)
		countSet.push(countOne)
		
		const countTwoTexture = new PIXI.Texture(counts)
		countTwoTexture.frame = new PIXI.Rectangle(200, 0, 200, 200)
		countTwo = new Sprite(countTwoTexture)
		countSet.push(countTwo)
		
		const countThreeTexture = new PIXI.Texture(counts)
		countThreeTexture.frame = new PIXI.Rectangle(400, 0, 200, 200)
		countThree = new Sprite(countThreeTexture)
		countSet.push(countThree)
		
		for (let item of countSet) {
			item.anchor.set(0.5, 0.5)
			item.scale.set(0.3)
			item.x = centerX
			item.y = centerY
			item.visible = false
			app.stage.addChild(item)
		}
		
		// correct fail hint
		correctBtn = new Sprite(new PIXI.Texture(correctImg))
		correctBtn.anchor.set(0.5)
		correctBtn.y = centerY - correctBtn.height / 2
		correctBtn.x = 80
		correctBtn.scale.set(0.5)
		correctBtn.alpha = 0
		
		failBtn = new Sprite(new PIXI.Texture(failImg))
		failBtn.anchor.set(0.5)
		failBtn.y = centerY - correctBtn.height / 2
		failBtn.x = 80
		failBtn.scale.set(0.5)
		failBtn.alpha = 0
		
		app.stage.addChild(correctBtn)
		app.stage.addChild(failBtn)
	}
	
	function playHandler (e) {
		e.stopPropagation()
		let self = this
		clickSound.play()
		self.texture = playBtnActiveTexture
		if (currentScene === 0) {
			
			// welcomeScene 向左隐藏
			new TWEEN.Tween(welcomeScene.position)
			.to({x: centerX * 2}, 500)
			.onUpdate(result => welcomeScene.x = result.x)
			.onComplete(() => currentScene = 1)
			.start()
			
			// introScene 向左隐藏
			new TWEEN.Tween(introScene.position)
			.to({x: 0}, 500)
			.onUpdate(result => introScene.x = result.x)
			.start()
		}
		if (currentScene === 1) {
			new TWEEN.Tween(gameScene.position)
			.to({x: 0}, 500)
			.onUpdate(obj => { gameScene.x = obj.x })
			.start()
			
			new TWEEN.Tween(introScene.position)
			.to({x: centerX * 2}, 500)
			.onUpdate(obj => { introScene.x = obj.x })
			.onComplete(() => {
				new TWEEN.Tween({
					scaleX: playButton.scale.x,
					scaleY: playButton.scale.y,
					y: playButton.position.y
				})
				.easing(TWEEN.Easing.Bounce.Out)
				.to({
					scaleX: 0.8,
					scaleY: 0.8,
					y: centerY * 2 - 40
				}, 400)
				.onUpdate(result => {
					playButton.scale.set(result.scaleX, result.scaleY)
					playButton.position.y = result.y
				})
				.start()
				renderCount(countSet)
				currentScene = 3
			})
			.start()
		}
	}
	
	function playUpHandler (e) {
		e.stopPropagation()
		this.texture = playBtnTexture
	}
	
	animate()
	
	function animate () {
		requestAnimationFrame(animate)
		TWEEN.update()
	}

</script>
</body>
</html>
