<!doctype html>
<html lang='en'>
<head>
  <meta charset='UTF-8'>
  <meta name='viewport'
    content='width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0'>
  <meta http-equiv='X-UA-Compatible' content='ie=edge'>
  <title>pixi.js tutorial</title>
  <script src='./lib/tween.umd.js'></script>
  <script src='./lib/pixi.js'></script>
  <script src='./lib/pixi-sound.js'></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
      'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
      'Noto Color Emoji';
    }
    
    ul, li {
      list-style: none;
    }
    
    html, body {
    }
    
    .playground canvas {
      display: block;
      margin: 0 auto;
    }
    
    .game-title {
      text-align: center;
      font-size: 24px;
      line-height: 2;
    }
    
    .game-info {
      margin: 30px auto;
      width: 80%;
      line-height: 1.2;
    }
    
    .game-info section {
      margin-bottom: 20px;
    }
    
    .game-info__title {
      margin-bottom: 10px;
    }
    
    .mb10 {
      padding: 10px 0;
      margin-bottom: 10px;
      border-bottom: 1px solid #ccc;
    }
  </style>
</head>
<body>
<h1 class='game-title'>Frantic-calculation</h1>
<div class='playground'></div>
<div class='game-info'>
  <section>
    <h3 class='game-info__title'>Training focus</h3>
    <div class='game-info__desc'>
      <ul>
        <li>Concentration</li>
        <li>Attention span</li>
        <li>Mathematical skills</li>
        <li>Long-term and working memory</li>
        <li>Speed</li>
        <li>Executive functions</li>
      </ul>
    </div>
  </section>
  <section>
    <h3 class='game-info__title'>Principles of the training</h3>
    <div class='game-info__desc'>
      <ul>
        <li>
          The game improves concentration on one element and at the same time increases the attention span needed for
          several tasks. Recalling of automated numerical responses develops mathematical skills and long-term memory.
          Solving priority tasks and verifying the accuracy of the results support executive functions.
        </li>
        <li>
          Working in a time limit improves the response speed.
        </li>
      </ul>
    </div>
  </section>
  <section>
    <h3 class='game-info__title'>How to play this game</h3>
    <div class='game-info__desc'>
      <p class='mb10'>
        The main goal of this game is to compute easy mathematical equations displayed inside falling lava stones. You
        can enter the results by using the numerical keyboard or by clicking on the numbers displayed in the game.
      </p>
      <p class='mb10'>
        The number and speed of the falling stones increases. Therefore, take the advantage of the blue ice stones that
        help you to get rid of all the other falling lava stones. When you compute the equation inside of the blue
        stones, you get extra bonus points.
      </p>
    </div>
  </section>
</div>
<script>
	const options = {
		width: 615,
		height: 505,
		transparent: false,
		backgroundColor: 0XEEEEEE
	}
	const app = new PIXI.Application(options)
	let clickSound, successSound, errorSound, flipSound
	const countTime = 1000
	let angle = 30
	
	function initSound () {
		// 声音
		const manifest = {
			success: './assets/sound/success.mp3',
			click: './assets/sound/click.mp3',
			error: './assets/sound/error.mp3',
			levelwon: './assets/sound/levelwon.mp3',
			flip: './assets/sound/flip.mp3'
		}
		
		// add to PIXI loader
		PIXI.sound.volumeAll = 100
		for (let resource in manifest) {
			PIXI.Loader.shared.add(resource, manifest[resource])
		}
		// preload the sounds
		PIXI.Loader.shared.load(function (loader, resources) {
			clickSound = resources['click'].sound
			successSound = resources['success'].sound
			errorSound = resources['error'].sound
			flipSound = resources['flip'].sound
		})
	}
	
	const playground = document.querySelector('.playground')
	playground.appendChild(app.view)
	
	const centerX = app.renderer.view.width / 2
	const centerY = app.renderer.view.height / 2
	const loader = new PIXI.Loader()
	const Sprite = PIXI.Sprite
	const Texture = PIXI.Texture
	
	let currentScene = 0
	
	let playBtnActiveTexture, playBtnTexture, playButton,
		welcomeScene, introScene, gameScene,
		correctBtn, failBtn,
		countOne, countTwo, countThree, counterInterval, countSet = [],
		textureCache,
		level = 2, lives = 3, computedGroup, calculatorGroup
	
	const operators = [
		{type: 'plus', text: '+'},
		{type: 'minus', text: '-'},
		{type: 'multiple', text: '×'},
		{type: 'divide', text: '÷'}
	]
	
	// 所有正在运动的待计算的item
	let computedItems = []
	
	// 每生成一条该值加1，作为该条item的name
	let computedIndex = 0
	let keyboardHandler = null
	
	// welcome, introduce scene animate params
	let transform = {
		x: 0
	}
	let introTransform = {
		posX: -centerX * 2
	}
	let gameTransform = {
		x: -centerX * 2
	}
	
	const rightPanelWidth = 194
	
	// 加载图片转化成纹理
	loader
	.add('welcome', './assets/calc/en/title_screen.png')
	.add('intro', './assets/calc/en/instructions.png')
	.add('correctImg', './assets/calc/common/sign_ok.png')
	.add('failImg', './assets/calc/common/sign_fail.png')
	
	.add('fire_drop', './assets/calc/common/fire_drop.png')
	.add('ice_drop', './assets/calc/common/ice_drop.png')
	.add('lava', './assets/calc/common/lava.png')
	
	.add('calculator0', './assets/calc/common/calculator0.png')
	.add('calculatorNum', './assets/calc/common/calculate1-9.jpg')
	.add('calculatorBackground', './assets/calc/common/calculatorBackground.png')
	.add('calculatorButtonGrid', './assets/calc/common/calculatorButtonGrid.png')
	.add('calculatorBack', './assets/calc/en/calculatorBack.png')
	.add('calculatorDel', './assets/calc/en/calculatorDel.png')
	.add('calculatorEnter', './assets/calc/common/calculatorEnter.png')
	
	.add('gameBackground', './assets/calc/common/gameBackground.png')
	.add('playBtn', './assets/calc/en/button_play.png')
	.add('counts', './assets/calc/common/counts.png')
	.load(setup)
	
	// 补零
	function zeroFill (num) {
		return num < 10 ? '0' + num : num
	}
	
	// 不包含最大值，用于在取数组中任意数
	function getRangeNum (min, max) {
		return Math.floor(Math.random() * (max - min)) + min
	}
	
	// shuffle array，数组混淆
	function shuffle (array) {
		for (let i = array.length - 1; i > 0; i--) {
			let j = Math.floor(Math.random() * (i + 1));
			[array[i], array[j]] = [array[j], array[i]]
		}
	}
	
	// 生成虚拟键盘，响应键盘操作
	function renderFakeKeyboard () {
		if (calculatorGroup) {
			gameScene.removeChild(calculatorGroup)
		}
		calculatorGroup = new PIXI.Container()
		const {
			calculatorBackground,
			calculatorButtonGrid,
			calculator0,
			calculatorNum,
			calculatorBack,
			calculatorEnter,
			calculatorDel,
			lava
		} = textureCache
		
		calculatorGroup.pivot.x = calculatorGroup.width / 2
		calculatorGroup.pivot.y = calculatorGroup.height / 2
		
		calculatorGroup.x = centerX * 2 - 170
		calculatorGroup.y = 100
		
		app.stage.addChild(calculatorGroup)
		
		const calculatorBackSprite = new Sprite(new Texture(calculatorBackground))
		const calculatorGridSprite = new Sprite(new Texture(calculatorButtonGrid))
		
		calculatorGridSprite.x = 11
		calculatorGridSprite.y = 86
		
		calculatorGroup.addChild(calculatorBackSprite)
		calculatorGroup.addChild(calculatorGridSprite)
		const nums = []
		
		// 数字 1~9
		let numText = 1
		for (let i = 0; i < 18; i += 2) {
			let numberTexture = new PIXI.Texture(calculatorNum)
			numberTexture.frame = new PIXI.Rectangle(i * 32, 0, 31, 31)
			const num = new Sprite(numberTexture)
			num.x = 12 + nums.length % 3 * 33
			num.y = 87 + (nums.length >= 3 && ((nums.length >= 6 ? 2 : 1) * 34))
			nums.push({
				normal: numberTexture,
				sprite: num,
				value: numText
			})
			calculatorGroup.addChild(num)
			numText++
		}
		
		let j = 0
		for (let i = 1; i < 18; i += 2) {
			let numberTexture = new PIXI.Texture(calculatorNum)
			numberTexture.frame = new PIXI.Rectangle(i * 32, 0, 31, 31)
			nums[j].active = numberTexture
			j++
		}
		
		// 数字 0
		let temp = {}
		let number0Texture = new PIXI.Texture(calculator0)
		number0Texture.frame = new PIXI.Rectangle(0, 0, 64, 32)
		temp.normal = number0Texture
		const num0 = new Sprite(number0Texture)
		num0.x = 12
		num0.y = 187
		calculatorGroup.addChild(num0)
		
		let number0TextureActive = new PIXI.Texture(calculator0)
		number0TextureActive.frame = new PIXI.Rectangle(64, 0, 64, 32)
		temp.active = number0TextureActive
		nums.push({
			sprite: num0,
			normal: temp.normal,
			active: temp.active,
			value: 0
		})
		
		// 操作按钮 backspace
		let numberBack = new PIXI.Texture(calculatorBack)
		numberBack.frame = new PIXI.Rectangle(0, 0, 32, 32)
		temp.normal = numberBack
		const numBack = new Sprite(numberBack)
		numBack.x = 77
		numBack.y = 187
		calculatorGroup.addChild(numBack)
		
		let numberBackActive = new PIXI.Texture(calculatorBack)
		numberBackActive.frame = new PIXI.Rectangle(32, 0, 32, 32)
		temp.active = numberBackActive
		nums.push({
			sprite: numBack,
			normal: temp.normal,
			active: temp.active,
			value: 'back'
		})
		
		// 操作按钮 delete
		let numberDel = new PIXI.Texture(calculatorDel)
		numberDel.frame = new PIXI.Rectangle(0, 0, 36, 65)
		temp.normal = numberDel
		const numDel = new Sprite(numberDel)
		numDel.x = 110
		numDel.y = 87
		calculatorGroup.addChild(numDel)
		
		let numberDelActive = new PIXI.Texture(calculatorDel)
		numberDelActive.frame = new PIXI.Rectangle(36, 0, 36, 65)
		temp.active = numberDelActive
		nums.push({
			sprite: numDel,
			normal: temp.normal,
			active: temp.active,
			value: 'del'
		})
		
		let numberEnter = new PIXI.Texture(calculatorEnter)
		numberEnter.frame = new PIXI.Rectangle(0, 0, 36, 65)
		temp.normal = numberEnter
		const numEnter = new Sprite(numberEnter)
		numEnter.x = 110
		numEnter.y = 154
		calculatorGroup.addChild(numEnter)
		
		let numberEnterActive = new PIXI.Texture(calculatorEnter)
		numberEnterActive.frame = new PIXI.Rectangle(36, 0, 36, 65)
		temp.active = numberEnterActive
		nums.push({
			sprite: numEnter,
			normal: temp.normal,
			active: temp.active,
			value: 'enter'
		})
		let inputNum = ''
		let inputNumSprite = null
		
		// 响应键盘操作
		const delHandler = () => {
			inputNum = ''
			inputNumSprite && (calculatorGroup.removeChild(inputNumSprite))
		}
		const backHandler = () => {
			if (inputNum.length) {
				inputNum = inputNum.substring(0, inputNum.length - 1)
				inputNumSprite && (calculatorGroup.removeChild(inputNumSprite))
				inputNumSprite = new PIXI.Text(inputNum, {
					fontSize: 28,
					fill: '#EB6B44'
				})
				inputNumSprite.y = 32
				inputNumSprite.x = 140 - inputNumSprite.width
				calculatorGroup.addChild(inputNumSprite)
			}
		}
		const numHandler = val => {
			inputNumSprite && (calculatorGroup.removeChild(inputNumSprite))
			inputNum.length < 8 && (inputNum += val + '')
			inputNumSprite = new PIXI.Text(inputNum, {
				fontSize: 28,
				fill: '#EB6B44'
			})
			inputNumSprite.y = 32
			inputNumSprite.x = 140 - inputNumSprite.width
			calculatorGroup.addChild(inputNumSprite)
		}
		const enterHandler = () => {
			console.log(computedItems, '计算前', inputNum)
			const isWrong = computedItems.every(item => item.answer !== Number(inputNum))
			if (isWrong) {
				errorSound.play()
			} else {
				successSound.play()
				for (let i = computedItems.length - 1; i >= 0; i--) {
					if (computedItems[i].answer === Number(inputNum)) {
						console.log('相等', i)
						computedGroup.removeChild(computedGroup.getChildByName(computedItems[i].name))
						computedItems.splice(i, 1)
					}
				}
				// 检测正确之后再次检测当前待测试的数量，数量较少立即再次渲染
				if (computedItems.length < level) {
					renderGameLogic()
				}
			}
			inputNum = ''
			inputNumSprite && (calculatorGroup.removeChild(inputNumSprite))
			console.log(computedItems, '计算后')
		}
		
		for (let i = 0; i < nums.length; i++) {
			nums[i].sprite.interactive = true
			nums[i].sprite.buttonMode = true
			
			nums[i].sprite.on('pointerover', () => {
				nums[i].sprite.texture = nums[i].active
			})
			
			nums[i].sprite.on('pointerout', () => {
				nums[i].sprite.texture = nums[i].normal
			})
			
			nums[i].sprite.on('pointerdown', () => {
				switch (nums[i].value) {
					case 'back':
						backHandler()
						break
					case 'enter':
						enterHandler()
						break
					case 'del':
						delHandler()
						break
					default:
						numHandler(nums[i].value)
						break
				}
			})
		}
		
		keyboardHandler = e => {
			const nums = [...new Array(10).keys()]
			if (nums.includes(Number(e.key))) {
				e.preventDefault()
				numHandler(Number(e.key))
			} else if (e.key === 'Enter') {
				e.preventDefault()
				enterHandler()
			} else if (e.key === 'Backspace') {
				e.preventDefault()
				backHandler()
			}
		}
		
		window.addEventListener('keydown', keyboardHandler, false)
		
		// 添加当前游戏状态
		const titleStyle = {
			fontSize: 18
		}
		const liveText = new PIXI.Text('Lives remaining: ' + lives, titleStyle)
		liveText.x = 4
		liveText.y = 250
		calculatorGroup.addChild(liveText)
		
		const levelText = new PIXI.Text('Level:' + level, titleStyle)
		levelText.x = 4
		levelText.y = 272
		calculatorGroup.addChild(levelText)
		
		const tipsTitleText = new PIXI.Text('Tip: ', {fontSize: 16})
		tipsTitleText.x = 4
		tipsTitleText.y = 306
		calculatorGroup.addChild(tipsTitleText)
		
		const tipsText = new PIXI.Text('use your numeric pad for faster answers', {
			fontSize: 14,
			wordWrap: true,
			wordWrapWidth: 172
		})
		tipsText.x = 4
		tipsText.y = 326
		
		calculatorGroup.addChild(tipsTitleText)
		calculatorGroup.addChild(tipsText)
		
		// 添加底部掉落限制区域
		const lavaSprite = new Sprite(lava)
		lavaSprite.y = centerY * 2 - lavaSprite.height
		gameScene.addChild(lavaSprite)
	}
	
	// 游戏业务代码
	// 生成computedItem，键盘输入 或 右侧模拟数字键盘输入后 enter 键，检测答案正确性
	// 生成当前游戏状态，remain lives以及当前level
	function renderGameLogic () {
		if (computedItems.length > level) return
		keyboardHandler && window.removeEventListener('keydown', keyboardHandler, false)
		// if (computedGroup !== undefined && computedGroup.children.length) {
		// 	gameScene.removeChild(computedGroup)
		// }
		computedGroup = new PIXI.Container()
		renderFakeKeyboard()
		
		const {
			fire_drop,
			ice_drop
		} = textureCache
		
		// 添加掉落待计算item
		
		gameScene.addChild(computedGroup)
		const renderDrop = () => {
			const drop = new Sprite(fire_drop)
			const iceDrop = new Sprite(ice_drop)
			const drops = [drop, iceDrop]
			
			for (let i = 0; i < drops.length; i++) {
				drops[i].anchor.set(0.5)
				drops[i].x = getRangeNum(drop.width / 2, centerX * 2 - rightPanelWidth - drop.width / 2)
				drops[i].y = drop.height / 2 + 10
				drops[i].name = 'index-' + computedIndex
			}
			
			computedGroup.addChild(drop)
			
			// 生成继续条目
			const operator = operators[getRangeNum(0, operators.length)]
			let str = ''
			
			let firstNum = 0
			let lastNum = 0
			
			switch (operator.type) {
				case 'minus':
					if (level > 4) {
						firstNum = getRangeNum(11, 30)
						lastNum = getRangeNum(1, 11)
					} else {
						firstNum = getRangeNum(6, 11)
						lastNum = getRangeNum(1, 6)
					}
					str = firstNum + operator.text + lastNum
					computedItems.push({
						sprite: drop,
						answer: firstNum - lastNum,
						visible: true,
						name: drop.name
					})
					break
				case 'multiple':
					if (level > 4) {
						firstNum = getRangeNum(1, 11)
						lastNum = getRangeNum(1, 11)
					} else {
						firstNum = getRangeNum(1, 6)
						lastNum = getRangeNum(1, 6)
					}
					str = firstNum + operator.text + lastNum
					computedItems.push({
						sprite: drop,
						answer: firstNum * lastNum,
						visible: true,
						name: drop.name
					})
					break
				case 'divide':
					if (level > 4) {
						lastNum = getRangeNum(1, 11)
						firstNum = lastNum * getRangeNum(1, 6)
					} else {
						lastNum = getRangeNum(1, 6)
						firstNum = lastNum * getRangeNum(1, 6)
					}
					str = firstNum + operator.text + lastNum
					computedItems.push({
						sprite: drop,
						answer: firstNum / lastNum,
						visible: true,
						name: drop.name
					})
					break
				default:
					if (level > 5) {
						lastNum = getRangeNum(1, 30)
						firstNum = getRangeNum(1, 30)
					} else {
						lastNum = getRangeNum(1, 10)
						firstNum = getRangeNum(1, 10)
					}
					str = firstNum + operator.text + lastNum
					computedItems.push({
						sprite: drop,
						answer: firstNum + lastNum,
						visible: true,
						name: drop.name
					})
					break
			}
			
			const contentText = new PIXI.Text(str, {
				fontSize: 22,
				fontWeight: 'bold',
				breakWords: true,
				wordWrap: true,
				lineHeight: 20
			})
			
			contentText.anchor.set(0.5)
			contentText.y = 28
			drop.addChild(contentText)
			computedIndex++
			
			const posTransform = {y: drop.position.y}
			const alpha = {alpha: 0}
			drop.alpha = alpha.alpha
			
			const alphaTween = new TWEEN.Tween(alpha)
			.to({alpha: 1}, 400)
			.onUpdate(result => { drop.alpha = result.alpha})
			
			const yTween = new TWEEN.Tween(posTransform)
			.to({y: centerY * 2}, 620000)
			.onUpdate(result => { drop.y = result.y })
			.onComplete(() => {
				gameScene.removeChild(computedGroup)
				computedItems.length = 0
			})
			
			alphaTween.chain(yTween)
			alphaTween.start()
		}
		for (let i = 0; i < level; i++) {
			renderDrop()
		}
		
	}
	
	// 游戏开始倒计时
	function renderCount (sprites) {
		const three = sprites[2]
		const two = sprites[1]
		const one = sprites[0]
		
		const countAnimate = (obj, callback) => {
			console.log(obj, 'countAnimate')
			obj.visible = true
			const scales = {x: obj.scale.x, y: obj.scale.y}
			const tween = new TWEEN.Tween(scales)
			
			tween.to({
				x: 0.5,
				y: 0.5
			}, countTime)
			.onUpdate(result => {
				obj.scale.set(result.x, result.y)
			})
			.onComplete(() => {
				app.stage.removeChild(obj)
				callback && callback()
			})
			return tween
		}
		const threeStart = countAnimate(three)
		const twoStart = countAnimate(two)
		const oneStart = countAnimate(one, () => {
			renderGameLogic()
			TWEEN.remove(threeStart)
			TWEEN.remove(twoStart)
			TWEEN.remove(oneStart)
		})
		
		threeStart.chain(twoStart)
		twoStart.chain(oneStart)
		
		threeStart.start()
	}
	
	// 游戏结束逻辑
	function gameOverHandler () {
		clearInterval(counterInterval)
		const tween = new TWEEN.Tween(gameScene.position)
		.to({
			x: centerX * 2
		})
		.onUpdate(result => {
			gameScene.x = result.x
		})
		.onComplete(() => {
			app.stage.removeChild(gameScene)
			const gameOverText = new PIXI.Text('GAME OVER', {
				fontSize: 48,
				fill: 0XEA432B,
				fontWeight: 800
			})
			const alpha = {
				val: 0
			}
			gameOverText.y = centerY - gameOverText.height / 2
			gameOverText.x = centerX - gameOverText.width / 2
			gameOverText.alpha = alpha.val
			app.stage.addChild(gameOverText)
			
			const alphaTween = new TWEEN.Tween(alpha)
			.to({
				val: 1
			})
			.onUpdate(result => {
				gameOverText.alpha = result.val
			})
			alphaTween.start()
		})
		tween.start()
	}
	
	// 初始化多个游戏场景, start -> introduce -> ready
	function setup () {
		initSound()
		textureCache = PIXI.utils.TextureCache
		const {
			welcome,
			playBtn,
			intro,
			gameBackground,
			counts,
			correctImg,
			failImg
		} = textureCache
		
		// 游戏元素
		
		welcomeScene = new Sprite(new Texture(welcome))
		introScene = new Sprite(new Texture(intro))
		
		welcomeScene.x = transform.x
		introScene.x = introTransform.posX
		
		playBtnTexture = new Texture(playBtn)
		playBtnTexture.frame = new PIXI.Rectangle(0, 0, 150, 55)
		
		playBtnActiveTexture = new Texture(playBtn)
		playBtnActiveTexture.frame = new PIXI.Rectangle(0, 55, 150, 55)
		
		playButton = new Sprite(playBtnTexture)
		playButton.x = (centerX * 2 - playButton.width) / 2
		playButton.y = centerY * 2 - 80
		
		playButton.interactive = true
		playButton.buttonMode = true
		
		playButton.on('pointerdown', playHandler)
		playButton.on('pointerup', playUpHandler)
		
		app.stage.addChild(welcomeScene)
		app.stage.addChild(introScene)
		app.stage.addChild(playButton)
		
		// gameContent
		let gameBg = new Sprite(new Texture(gameBackground))
		
		gameScene = new PIXI.Container()
		gameScene.x = gameTransform.x
		gameScene.addChild(gameBg)
		app.stage.addChild(gameScene)
		
		const countOneTexture = new PIXI.Texture(counts)
		countOneTexture.frame = new PIXI.Rectangle(0, 0, 200, 200)
		countOne = new Sprite(countOneTexture)
		countSet.push(countOne)
		
		const countTwoTexture = new PIXI.Texture(counts)
		countTwoTexture.frame = new PIXI.Rectangle(200, 0, 200, 200)
		countTwo = new Sprite(countTwoTexture)
		countSet.push(countTwo)
		
		const countThreeTexture = new PIXI.Texture(counts)
		countThreeTexture.frame = new PIXI.Rectangle(400, 0, 200, 200)
		countThree = new Sprite(countThreeTexture)
		countSet.push(countThree)
		
		for (let item of countSet) {
			item.anchor.set(0.5, 0.5)
			item.scale.set(0.3)
			item.x = centerX
			item.y = centerY
			item.visible = false
			app.stage.addChild(item)
		}
		
		// correct fail hint
		correctBtn = new Sprite(new PIXI.Texture(correctImg))
		correctBtn.anchor.set(0.5)
		correctBtn.y = centerY - correctBtn.height / 2
		correctBtn.x = 80
		correctBtn.scale.set(0.5)
		correctBtn.alpha = 0
		
		failBtn = new Sprite(new PIXI.Texture(failImg))
		failBtn.anchor.set(0.5)
		failBtn.y = centerY - correctBtn.height / 2
		failBtn.x = 80
		failBtn.scale.set(0.5)
		failBtn.alpha = 0
		
		app.stage.addChild(correctBtn)
		app.stage.addChild(failBtn)
	}
	
	function playHandler (e) {
		e.stopPropagation()
		let self = this
		clickSound.play()
		self.texture = playBtnActiveTexture
		if (currentScene === 0) {
			const tween = new TWEEN.Tween(transform)
			.to({
				x: centerX * 2
			}, 500)
			.onUpdate(updateScene1Handler)
			.onComplete(() => {
				currentScene = 1
			})
			
			const introSceneTween = new TWEEN.Tween(introTransform)
			.to({
				posX: 0
			}, 500)
			.onUpdate(updateScene2Handler)
			
			tween.start()
			introSceneTween.start()
			
			function updateScene1Handler (object) {
				welcomeScene.x = object.x
			}
			
			function updateScene2Handler (object) {
				introScene.x = object.posX
			}
		}
		if (currentScene === 1) {
			self.alpha = 0
			const tween = new TWEEN.Tween(gameTransform)
			.to({
				x: 0
			}, 500)
			.onUpdate(obj => {
				gameScene.x = obj.x
			})
			
			const introTrans = new TWEEN.Tween(introTransform)
			.to({
				posX: centerX * 2
			}, 500)
			.onUpdate(obj => {
				introScene.x = obj.posX
			})
			.onComplete(() => {
				app.stage.removeChild(playButton)
				renderCount(countSet)
			})
			
			tween.start()
			introTrans.start()
		}
	}
	
	function playUpHandler (e) {
		e.stopPropagation()
		this.texture = playBtnTexture
	}
	
	animate()
	
	function animate () {
		requestAnimationFrame(animate)
		TWEEN.update()
	}

</script>
</body>
</html>
