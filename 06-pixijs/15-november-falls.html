<!doctype html>
<html lang='en'>
<head>
  <meta charset='UTF-8'>
  <meta name='viewport'
    content='width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0'>
  <meta http-equiv='X-UA-Compatible' content='ie=edge'>
  <title>pixi.js tutorial</title>
  <script src='./lib/tween.umd.js'></script>
  <script src='./lib/pixi.min.js'></script>
  <script src='./lib/pixi-sound.js'></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
      'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
      'Noto Color Emoji';
    }
    
    ul, li {
      list-style: none;
    }
    
    html, body {
    }
    
    .playground canvas {
      display: block;
      margin: 0 auto;
    }
    
    .game-title {
      text-align: center;
      font-size: 24px;
      line-height: 2;
    }
    
    .game-info {
      margin: 30px auto;
      width: 80%;
      line-height: 1.2;
    }
    
    .game-info section {
      margin-bottom: 20px;
    }
    
    .game-info__title {
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
<h1 class='game-title'>November Fallss</h1>
<div class='playground'></div>
<div class='game-info'>
  <section>
    <h3 class='game-info__title'>Training focus</h3>
    <div class='game-info__desc'>
      <ul>
        <li>Short-term memory</li>
        <li>Concentration</li>
        <li>Attention distribution</li>
        <li>Reaction speed</li>
      </ul>
    </div>
  </section>
  <section>
    <h3 class='game-info__title'>Principles of the training</h3>
    <div class='game-info__desc'>
      <ul>
        <li>
          The game trains concentration on individual elements and it also develops executive functions, such as
          decision-making efficiency, correct answer feedback and awareness of rule changes.
        </li>
        <li>
          The game also supports the development of short-term memory because the hints disappear during the training,
          so the player has to remember the complicated rules.
        </li>
        <li>
          Working in a time limit improves the response speed.
        </li>
      </ul>
    </div>
  </section>
  <section>
    <h3 class='game-info__title'>How to play this game</h3>
    <div class='game-info__desc'>
      <p>
        The aim of this game is to classify correctly the falling leaves according to the given instructions.
        **Orange leaf** - Decide if **the letter** inside the leaf is **a vowel**.
        **Yellow leaf** - Decide if **the number** inside the leaf is **odd**.
      </p>
      <p>
        
        <img src="./assets/novermber-falls/listopad_brown_4B_trn.png" alt="4B" />
        Color of the leaf is orange. The goal is to decide whether the letter is a vowel.
        B is not a vowel, so the correct answer is NO (**the left arrow**).
      </p>
      <p>
        <img src='./assets/novermber-falls/listopad_green_3A_trn.png' alt='3A' />
        This time the leaf is yellow. The goal is to determine if the number is odd. Number 3 is odd,
        therefore the correct answer is YES (**right arrow**).
        Pay attention: a wrong answer as well as letting the leaf fall down leads to minus points.
      </p>
    </div>
  </section>
</div>
<script>
	const options = {
		width: 615,
		height: 505,
		transparent: false,
		backgroundColor: 0XEEEEEE
	}
	const app = new PIXI.Application(options)
	let clickSound, successSound, errorSound
	
	function initSound () {
		// 声音
		const manifest = {
			success: './assets/sound/success.mp3',
			click: './assets/sound/click.mp3',
			error: './assets/sound/error.mp3'
		}
		
		// add to PIXI loader
		PIXI.sound.volumeAll = 100
		for (let resource in manifest) {
			PIXI.Loader.shared.add(resource, manifest[resource])
		}
		// preload the sounds
		PIXI.Loader.shared.load(function (loader, resources) {
			clickSound = resources['click'].sound
			successSound = resources['success'].sound
			errorSound = resources['error'].sound
		})
	}
	
	const playground = document.querySelector('.playground')
	playground.appendChild(app.view)
	
	const centerX = app.renderer.view.width / 2
	const centerY = app.renderer.view.height / 2
	const loader = new PIXI.Loader()
	const Sprite = PIXI.Sprite
	const Texture = PIXI.Texture
	
	let currentScene = 0
	
	let playBtnActiveTexture, playBtnTexture, playButton,
		welcomeScene, introScene, gameScene,
		correctBtn, failBtn,
		countOne, countTwo, countThree, counterInterval, countSet = [],
		leafContainer, greenLeafTexture, brownLeafTexture, leafGroup,
		yesBtn, nopeBtn, activeSelectTexture, selectTexture,
		controlGroup, correctAnswer = 'none'
	
	let transform = {
		x: 0
	}
	let introTransform = {
		posX: -centerX * 2
	}
	let gameTransform = {
		x: -centerX * 2
	}
	
	// 加载图片转化成纹理
	loader
	.add('welcome', './assets/novermber-falls/en/title_screen.png')
	.add('intro', './assets/novermber-falls/en/instructions.png')
	.add('correctImg', './assets/novermber-falls/common/sign_ok.png')
	.add('failImg', './assets/cards/common/sign_fail.png')
	
	.add('brownLeafImg', './assets/novermber-falls/common/leafBrown.png')
	.add('greenLeafImg', './assets/novermber-falls/common/leafGreen.png')
	
	.add('gameBackground', './assets/novermber-falls/common/gameBackground.png')
	.add('playBtn', './assets/novermber-falls/en/button_play.png')
	.add('answerArrow', './assets/novermber-falls/common/arrowRight.png')
	.add('counts', './assets/novermber-falls/common/counts.png')
	.load(setup)
	
	// 补零
	function zeroFill (num) {
		return num < 10 ? '0' + num : num
	}
	
	function getRangeNum (min, max) {
		return Math.floor(Math.random() * (max - min)) + min
	}
	
	// 游戏业务代码
	function renderGameLogic () {
		correctAnswer = 'none'
		/*
		* 展示区始终有只有一片叶子
		* 叶子区域由字母 + 数字组成
		* 黄色的叶子-> 要求用户区分叶子内容是否为 奇数，
		* 金色的叶子-> 要求用户区分叶子内容是否为 元音 a|o|e|i|u
		* */
		if (leafContainer !== undefined && leafContainer.children.length) {
			gameScene.removeChild(leafContainer)
		}
		
		if (controlGroup !== undefined && controlGroup.children.length) {
			gameScene.removeChild(controlGroup)
		}
		leafContainer = new PIXI.Container()
		
		const letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'O', 'P', 'Q', 'U', 'Z']
		const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
		
		const greenLeaf = new Sprite(greenLeafTexture)
		const brownLeaf = new Sprite(brownLeafTexture)
		leafGroup = [greenLeaf, brownLeaf]
		
		const halfWidth = greenLeaf.width / 2
		const halfHeight = greenLeaf.height / 2
		const dropDuration = 10
		
		// 初始化位置
		const landscape = getRangeNum(halfWidth, centerX * 2 - halfWidth)
		const portrait = 60 + halfHeight
		
		// 添加叶子，确定叶子种类，配置绘制方法
		const leafType = getRangeNum(0, leafGroup.length)
		const currentLeaf = leafGroup[leafType]
		
		currentLeaf.anchor.set(0.5)
		currentLeaf.name = `leaf-${leafType}`
		currentLeaf.scale.set(0.8)
		currentLeaf.x = landscape
		currentLeaf.y = portrait
		
		// 添加叶子中内容
		const letter = letters[getRangeNum(0, letters.length)]
		const number = numbers[getRangeNum(0, numbers.length)]
		
		const textForGreen = letter + '' + number
		const textForBrown = number + '' + letter
		
		const textStyleForGreen = {
			fill: '#FFFFFF',
			stroke: '#D6B300',
			fontWeight: 800,
			strokeThickness: 2
		}
		const textStyleForBrown = {
			fill: '#FFFFFF',
			stroke: '#DE5700',
			fontWeight: 800,
			strokeThickness: 2
		}
		
		const greenQues = 'Is number odd?'
		const brownQues = 'Is letter vowel?'
		
		let leafContent = ''
		let leafStyle = null
		let leafQes = ''
		
		if (leafType === 0) {
			leafContent = textForGreen
			leafStyle = textStyleForGreen
			leafQes = greenQues
			correctAnswer = number % 2 !== 0 ? 'yes' : 'no'
		} else {
			leafContent = textForBrown
			leafStyle = textStyleForBrown
			leafQes = brownQues
			correctAnswer = ['A', 'O', 'I', 'O', 'U'].includes(letter) ? 'yes' : 'no'
		}
		
		const textSprite = new PIXI.Text(leafContent, leafStyle)
		textSprite.name = 'leafContent'
		textSprite.anchor.set(0.5)
		textSprite.y = currentLeaf.y
		textSprite.x = currentLeaf.x
		
		leafContainer.addChild(currentLeaf)
		leafContainer.addChild(textSprite)
		leafContainer.width = currentLeaf.width
		leafContainer.height = currentLeaf.height
		
		// 添加叶子运动
		const transform = {
			y: leafContainer.y,
			alpha: 1
		}
		let dropTween = new TWEEN.Tween(transform)
		dropTween.to({
			y: centerY * 2 - halfHeight - currentLeaf.y,
			alpha: 0.2
		}, dropDuration * 1000)
		.onUpdate(result => {
			leafContainer.y = result.y
			leafContainer.alpha = result.alpha
		})
		.onStop(() => {
			// todo tween的实例会很多，会多次执行onComplete
			TWEEN.removeAll()
			gameScene.removeChild(leafContainer)
			renderGameLogic()
		})
		.onComplete(() => {
			gameScene.removeChild(leafContainer)
			renderGameLogic()
		})
		dropTween.start()
		
		// 添加container
		gameScene.addChild(leafContainer)
		
		// 添加操作按钮等
		controlGroup = new PIXI.Container()
		
		const btnHover = btn => {
			btn.on('pointerover', () => {
				btn.texture = activeSelectTexture
			})
			btn.on('pointerout', () => {
				btn.texture = selectTexture
			})
			btn.on('pointerdown', e => {
				checkHint(e.target.name)
				dropTween.stop()
			})
		}
		
		yesBtn = new Sprite(selectTexture)
		yesBtn.interactive = true
		yesBtn.buttonMode = true
		yesBtn.name = 'yes'
		yesBtn.anchor.set(0.5)
		yesBtn.rotation = -Math.PI
		yesBtn.scale.set(0.9)
		yesBtn.x = centerX - 40
		yesBtn.y = centerY + 190
		btnHover(yesBtn)
		
		const yesText = new PIXI.Text('Yes', {fontSize: 18})
		yesText.anchor.set(0.5)
		yesText.x = centerX - 86
		yesText.y = centerY + 192
		controlGroup.addChild(yesBtn)
		controlGroup.addChild(yesText)
		
		nopeBtn = new Sprite(selectTexture)
		nopeBtn.interactive = true
		nopeBtn.buttonMode = true
		nopeBtn.name = 'no'
		nopeBtn.anchor.set(0.5)
		nopeBtn.scale.set(0.9)
		nopeBtn.x = centerX + 40
		nopeBtn.y = centerY + 190
		btnHover(nopeBtn)
		
		const nopeText = new PIXI.Text('No', {fontSize: 18})
		nopeText.anchor.set(0.5)
		nopeText.x = centerX + 86
		nopeText.y = centerY + 192
		controlGroup.addChild(nopeBtn)
		controlGroup.addChild(nopeText)
		
		const questionSprite = new PIXI.Text(leafQes)
		questionSprite.anchor.set(0.5)
		questionSprite.x = centerX
		questionSprite.y = centerY + 140
		controlGroup.addChild(questionSprite)
		
		gameScene.addChild(controlGroup)
	}
	
	// 游戏开始倒计时
	function renderCount (sprites) {
		const three = sprites[2]
		const two = sprites[1]
		const one = sprites[0]
		
		const countAnimate = (obj, callback) => {
			obj.visible = true
			const scales = {x: obj.scale.x, y: obj.scale.y}
			const tween = new TWEEN.Tween(scales)
			
			tween.to({
				x: 0.5,
				y: 0.5
			}, 1000)
			.onUpdate(result => {
				obj.scale.set(result.x, result.y)
			})
			.onComplete(() => {
				app.stage.removeChild(obj)
				callback && callback()
			})
			return tween
		}
		const threeStart = countAnimate(three)
		const twoStart = countAnimate(two)
		const oneStart = countAnimate(one, () => {
			renderGameLogic()
			renderToolbar(40)
		})
		
		threeStart.chain(twoStart)
		twoStart.chain(oneStart)
		
		threeStart.start()
	}
	
	// 游戏计时及计分
	function renderToolbar (remains) {
		const toolbars = new PIXI.Container()
		const statue = new PIXI.Graphics()
		let time = remains
		let remainTime = null
		statue.beginFill(0X000000, 0.5)
		statue.drawRect(0, 0, centerX * 2, 40)
		statue.endFill()
		toolbars.addChild(statue)
		let textStyle = new PIXI.TextStyle({
			fontFamily: 'PingFang SC Regular',
			fontSize: 18,
			fill: '#FFFFFF',
			stroke: '#cd0000',
			align: 'center',
			lineHeight: 40,
			textBaseline: 'middle'
		})
		gameScene.addChild(toolbars)
		
		const renderText = () => {
			remainTime = new PIXI.Text(`Remaining time: 00:${zeroFill(time)}`, textStyle)
			remainTime.resolution = 2
			remainTime.x = centerX - remainTime.width / 2
			remainTime.y = 5
			toolbars.addChild(remainTime)
		}
		
		renderText()
		
		counterInterval = setInterval(() => {
			remainTime && toolbars.removeChild(remainTime)
			if (time === 0) {
				gameOverHandler()
			}
			if (time > 0) {
				time--
			}
			renderText()
		}, 1000)
	}
	
	// 游戏结束逻辑
	function gameOverHandler () {
		clearInterval(counterInterval)
		const tween = new TWEEN.Tween(gameScene.position)
		.to({
			x: centerX * 2
		})
		.onUpdate(result => {
			gameScene.x = result.x
		})
		.onComplete(() => {
			app.stage.removeChild(gameScene)
			const gameOverText = new PIXI.Text('GAME OVER', {
				fontSize: 48,
				fill: 0XEA432B,
				fontWeight: 800
			})
			const alpha = {
				val: 0
			}
			gameOverText.y = centerY - gameOverText.height / 2
			gameOverText.x = centerX - gameOverText.width / 2
			gameOverText.alpha = alpha.val
			app.stage.addChild(gameOverText)
			
			const alphaTween = new TWEEN.Tween(alpha)
			.to({
				val: 1
			})
			.onUpdate(result => {
				gameOverText.alpha = result.val
			})
			alphaTween.start()
		})
		tween.start()
	}
	
	// 游戏暂停逻辑
	function gamePauseHandler () {}
	
	// 游戏重启逻辑
	function gameRestartHandler () {
	
	}
	
	// 关闭游戏音效
	function gameMuteHandler () {
	
	}
	
	// 游戏数据统计，需要统计 正确数/总数，反应时间
	function gameDataCollect () {
	
	}
	
	// 游戏正误提示
	function checkHint (name) {
		if (!name) return
		const hint = sprite => {
			const transform = {
				alpha: sprite.alpha,
				x: sprite.scale.x,
				y: sprite.scale.y
			}
			let tween = new TWEEN.Tween(transform)
			.to({
				x: 0.8,
				y: 0.8,
				alpha: 1
			}, 200)
			.onUpdate(result => {
				sprite.scale.set(result.x, result.y)
				sprite.alpha = result.alpha
			})
			.onComplete(() => {
				sprite.alpha = 0
				sprite.scale.set(0.4, 0.4)
			})
			tween.start()
		}
		
		if (name !== correctAnswer) {
			hint(failBtn)
			errorSound.play()
		} else if (name === correctAnswer) {
			hint(correctBtn)
			successSound.play()
		}
		renderGameLogic()
	}
	
	// 初始化多个游戏场景, start -> introduce -> ready
	function setup () {
		initSound()
		const textureCache = PIXI.utils.TextureCache
		const {
			welcome,
			playBtn,
			intro,
			gameBackground,
			counts,
			correctImg,
			failImg,
			brownLeafImg,
			greenLeafImg,
			answerArrow
		} = textureCache
		
		welcomeScene = new Sprite(new Texture(welcome))
		introScene = new Sprite(new Texture(intro))
		
		welcomeScene.x = transform.x
		introScene.x = introTransform.posX
		
		playBtnTexture = new Texture(playBtn)
		playBtnTexture.frame = new PIXI.Rectangle(0, 55, 150, 55)
		
		playBtnActiveTexture = new Texture(playBtn)
		playBtnActiveTexture.frame = new PIXI.Rectangle(0, 0, 150, 55)
		
		selectTexture = new Texture(answerArrow)
		selectTexture.frame = new PIXI.Rectangle(0, 0, 55, 55)
		
		activeSelectTexture = new Texture(answerArrow)
		activeSelectTexture.frame = new PIXI.Rectangle(55, 0, 55, 55)
		
		playButton = new Sprite(playBtnTexture)
		playButton.x = (centerX * 2 - playButton.width) / 2
		playButton.y = centerY * 2 - 80
		
		playButton.interactive = true
		playButton.buttonMode = true
		
		playButton.on('pointerdown', playHandler)
		playButton.on('pointerup', playUpHandler)
		
		app.stage.addChild(welcomeScene)
		app.stage.addChild(introScene)
		app.stage.addChild(playButton)
		
		// gameContent
		let gameBg = new Sprite(new Texture(gameBackground))
		greenLeafTexture = new Texture(greenLeafImg)
		brownLeafTexture = new Texture(brownLeafImg)
		
		gameScene = new PIXI.Container()
		gameScene.x = gameTransform.x
		gameScene.addChild(gameBg)
		app.stage.addChild(gameScene)
		
		const countOneTexture = new PIXI.Texture(counts)
		countOneTexture.frame = new PIXI.Rectangle(0, 0, 200, 200)
		countOne = new Sprite(countOneTexture)
		countSet.push(countOne)
		
		const countTwoTexture = new PIXI.Texture(counts)
		countTwoTexture.frame = new PIXI.Rectangle(200, 0, 200, 200)
		countTwo = new Sprite(countTwoTexture)
		countSet.push(countTwo)
		
		const countThreeTexture = new PIXI.Texture(counts)
		countThreeTexture.frame = new PIXI.Rectangle(400, 0, 200, 200)
		countThree = new Sprite(countThreeTexture)
		countSet.push(countThree)
		
		for (let item of countSet) {
			item.anchor.set(0.5, 0.5)
			item.scale.set(0.3)
			item.x = centerX
			item.y = centerY
			item.visible = false
			app.stage.addChild(item)
		}
		
		// correct fail hint
		correctBtn = new Sprite(new PIXI.Texture(correctImg))
		correctBtn.anchor.set(0.5)
		correctBtn.y = centerY - correctBtn.height / 2
		correctBtn.x = 80
		correctBtn.scale.set(0.5)
		correctBtn.alpha = 0
		
		failBtn = new Sprite(new PIXI.Texture(failImg))
		failBtn.anchor.set(0.5)
		failBtn.y = centerY - correctBtn.height / 2
		failBtn.x = 80
		failBtn.scale.set(0.5)
		failBtn.alpha = 0
		
		app.stage.addChild(correctBtn)
		app.stage.addChild(failBtn)
	}
	
	function playHandler (e) {
		e.stopPropagation()
		let self = this
		clickSound.play()
		self.texture = playBtnActiveTexture
		if (currentScene === 0) {
			const tween = new TWEEN.Tween(transform)
			.to({
				x: centerX * 2
			}, 500)
			.onUpdate(updateScene1Handler)
			.onComplete(() => {
				currentScene = 1
			})
			
			const introSceneTween = new TWEEN.Tween(introTransform)
			.to({
				posX: 0
			}, 500)
			.onUpdate(updateScene2Handler)
			
			tween.start()
			introSceneTween.start()
			
			function updateScene1Handler (object) {
				welcomeScene.x = object.x
			}
			
			function updateScene2Handler (object) {
				introScene.x = object.posX
			}
		}
		if (currentScene === 1) {
			self.alpha = 0
			const tween = new TWEEN.Tween(gameTransform)
			.to({
				x: 0
			}, 500)
			.onUpdate(obj => {
				gameScene.x = obj.x
			})
			const introTrans = new TWEEN.Tween(introTransform)
			.to({
				posX: centerX * 2
			}, 500)
			.onUpdate(obj => {
				introScene.x = obj.posX
			})
			.onComplete(() => {
				app.stage.removeChild(playButton)
				renderCount(countSet)
			})
			
			tween.start()
			introTrans.start()
		}
	}
	
	function playUpHandler (e) {
		e.stopPropagation()
		this.texture = playBtnTexture
	}
	
	animate()
	
	function animate () {
		requestAnimationFrame(animate)
		TWEEN.update()
	}

</script>
</body>
</html>
