<!doctype html>
<html lang='en'>
<head>
  <meta charset='UTF-8'>
  <meta name='viewport'
    content='width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0'>
  <meta http-equiv='X-UA-Compatible' content='ie=edge'>
  <title>pixi.js tutorial</title>
  <script src='./lib/tween.umd.js'></script>
  <script src='./lib/pixi.js'></script>
  <script src='./lib/pixi-sound.js'></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
      'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
      'Noto Color Emoji';
    }
    
    ul, li {
      list-style: none;
    }
    
    html, body {
    }
    
    .playground canvas {
      display: block;
      margin: 0 auto;
    }
    
    .game-title {
      text-align: center;
      font-size: 24px;
      line-height: 2;
    }
    
    .game-info {
      margin: 30px auto;
      width: 80%;
      line-height: 1.2;
    }
    
    .game-info section {
      margin-bottom: 20px;
    }
    
    .game-info__title {
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
<h1 class='game-title'>Schulte Grid</h1>
<div class='playground'></div>
<div class='game-info'>
  <section>
    <h3 class='game-info__title'>Training focus</h3>
    <div class='game-info__desc'>
      <ul>
        <li>Concentration</li>
        <li>Attention span</li>
        <li>Mathematical skills</li>
        <li>Long-term and working memory</li>
        <li>Speed</li>
        <li>Executive functions</li>
      </ul>
    </div>
  </section>
  <section>
    <h3 class='game-info__title'>Principles of the training</h3>
    <div class='game-info__desc'>
      <ul>
        <li>
          舒尔特表（Schulte Grid）通过动态的练习锻炼视神经末梢。心理学上用此表来研究和发展心理感知的速度，其中包括视觉定向搜索运动的速度。
          
          用来培养注意力集中、分配、控制能力；拓展视幅；加快视频；提高视觉的稳定性、辨别力、定向搜索能力。练习的时间越长，看表所需的时间会越短。随着练习的深入，眼球的末梢视觉能力提高，不仅初学者可以有效地拓展视幅，加快阅读节奏，锻炼眼睛快速认读；而且对于进入提高阶段之后，同时拓展纵横视幅，达到一目十行、一目一页非常有效。
        </li>
      </ul>
    </div>
  </section>
</div>
<script>
	const options = {
		width: 615,
		height: 505,
		transparent: false,
		backgroundColor: 0XEEEEEE
	}
	
	const app = new PIXI.Application(options)
	let clickSound, successSound, errorSound, flipSound, explosionSound
	let correctIndex = 1
  let correctArr = []
	
	// shuffle array，数组混淆
	function shuffle (array) {
		for (let i = array.length - 1; i > 0; i--) {
			let j = Math.floor(Math.random() * (i + 1));
			[array[i], array[j]] = [array[j], array[i]]
		}
	}
	
	function initSound () {
		// 声音
		const manifest = {
			success: './assets/sound/success.mp3',
			click: './assets/sound/click.mp3',
			error: './assets/sound/error.mp3',
			levelwon: './assets/sound/levelwon.mp3',
			flip: './assets/sound/flip.mp3',
			explosion: './assets/sound/explosion.mp3'
		}
		
		// add to PIXI loader
		PIXI.sound.volumeAll = 100
		for (let resource in manifest) {
			PIXI.Loader.shared.add(resource, manifest[resource])
		}
		// preload the sounds
		PIXI.Loader.shared.load(function (loader, resources) {
			clickSound = resources['click'].sound
			successSound = resources['success'].sound
			errorSound = resources['error'].sound
			flipSound = resources['flip'].sound
			explosionSound = resources['explosion'].sound
		})
	}
	
	const playground = document.querySelector('.playground')
	playground.appendChild(app.view)
	
	const centerX = app.renderer.view.width / 2
	const centerY = app.renderer.view.height / 2
	const loader = new PIXI.Loader()
	const Sprite = PIXI.Sprite
	const Texture = PIXI.Texture
	
	// 生成外框
	const rectGraphic = new PIXI.Graphics()
	let RECT_SIZE = 150
	let radix = 2
  let rectNum, singleRectCenter, halfSingleRectSize, center, rects = [], positions = []
  
  const renderFrameAndPosition = () => {
	  if(radix === 4 || radix === 5){
		  RECT_SIZE = 300
	  } else if(radix === 3){
		  RECT_SIZE = 200
	  } else if (radix === 6){
		  RECT_SIZE = 360
	  }
	
	  rectNum = Math.pow(radix, 2)
	  singleRectCenter = RECT_SIZE / radix
	  halfSingleRectSize = RECT_SIZE / radix / 2
	
	  // 添加外框
	  rectGraphic.lineStyle(1, '0XCD0000', 1)
	  rectGraphic.pivot.set(centerX, centerY)
	  rectGraphic.position.set(centerX, centerY)
	
	  center = {
		  x: rectGraphic.x - RECT_SIZE / 2,
		  y: rectGraphic.y - RECT_SIZE / 2
	  }
	
	  for (let index = 0; index < rectNum; index++) {
		  let num = index + 1
		  positions.push({
			  x: center.x + RECT_SIZE / radix * (index % radix),
			  y: center.y + RECT_SIZE / radix * (num > radix && Math.floor(index / radix))
		  })
	  }
	  
	  shuffle(positions)
  }
	
	// 在panel下面显示当前的按键次序
  let pointerDownStr = null
  
	const pointerdownArr = arr => {
		const temp = [...arr]
		if(pointerDownStr) app.stage.removeChild(pointerDownStr)
  
		temp.reverse()
  
		const str = temp.join(',')
		pointerDownStr = new PIXI.Text(str, {fontSize: 24, wordWrap: true, wordWrapWidth: 400, breakWords: true})
		pointerDownStr.anchor.set(0.5)
		pointerDownStr.x = centerX
		pointerDownStr.y = centerY * 2 - 30
		app.stage.addChild(pointerDownStr)
	}
	
	const pointerHandler = (index, isRight) => {
		app.stage.removeChild(rects[index].graphic)
		app.stage.addChild(renderRectWithNum(index, isRight ? 0X00C957 : 0XFF0000, '#ffffff'))
    setTimeout(() => {
	    app.stage.removeChild(rects[index].graphic)
	    app.stage.addChild(renderRectWithNum(index))
    }, 500)
	}
	
	const renderRectWithNum = (index, rectColor = '0XFFFFFF', textColor = '0X000000') => {
		const num = index + 1
		const rect = new PIXI.Graphics()
		rect.lineStyle(1, '0XCD0000', 1)
		rectColor && rect.beginFill(rectColor, 1)
		
		rect.drawRect(positions[index].x, positions[index].y, singleRectCenter, singleRectCenter)
		rect.hitArea = new PIXI.Rectangle(positions[index].x, positions[index].y, singleRectCenter, singleRectCenter)
		rect.interactive = true
		rect.buttonMode = true
		
		// 生成数字
		const numText = new PIXI.Text(num, {fontSize: 36, fill: textColor})
		numText.anchor.set(0.5)
		numText.x = positions[index].x + halfSingleRectSize
		numText.y = positions[index].y + halfSingleRectSize
		
		rect.addChild(numText)
		
		rects.push({
			graphic: rect, index
		})
		
		rect.on('pointerdown', () => {
			console.log(correctIndex, rectNum, '什么秦孔')
			if (correctIndex > rectNum) {
				radix += 1
        // 重新渲染
				renderGameLogic()
        console.log('渲染完了')
        return
      }
			if ((index + 1) === correctIndex) {
				pointerHandler(index, true)
				correctArr.push(correctIndex)
				pointerdownArr(correctArr)
				correctIndex++
        console.log(correctIndex, '--->')
			} else {
				pointerHandler(index, false)
			}
		})
		
		app.stage.addChild(rect)
		
		return rect
	}
	
	const renderGameLogic = () => {
		if(rects.length > 0){
			for(let i = 0; i < rects.length; i++){
			  app.stage.removeChild(rects[i].graphic)
			}
			rects.splice(0)
			positions.splice(0)
			correctArr.splice(0)
			correctIndex = 1
    }
		
		renderFrameAndPosition()
		for (let i = 0; i < rectNum; i++) {
			renderRectWithNum(i)
		}
  }
	
	// 开始游戏
	renderGameLogic()
</script>
</body>
</html>
