<!doctype html>
<html lang='en'>
<head>
  <meta charset='UTF-8'>
  <meta name='viewport'
    content='width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0'>
  <meta http-equiv='X-UA-Compatible' content='ie=edge'>
  <title>pixi.js tutorial</title>
  <script src='./lib/tween.umd.js'></script>
  <script src='./lib/pixi.js'></script>
  <script src='./lib/pixi-sound.js'></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
      'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
      'Noto Color Emoji';
    }
    
    ul, li {
      list-style: none;
    }
    
    html, body {
    }
    
    .playground canvas {
      display: block;
      margin: 0 auto;
    }
    
    .game-title {
      text-align: center;
      font-size: 24px;
      line-height: 2;
    }
    
    .game-info {
      margin: 30px auto;
      width: 80%;
      line-height: 1.2;
    }
    
    .game-info section {
      margin-bottom: 20px;
    }
    
    .game-info__title {
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
<h1 class='game-title'>Rotate memory matrix</h1>
<div class='playground'></div>
<div class='game-info'>
  <section>
    <h3 class='game-info__title'>Training focus</h3>
    <div class='game-info__desc'>
      <ul>
        <li>Spatial orientation</li>
        <li>Short-term visual memory</li>
        <li>Attention span</li>
        <li>Reaction speed</li>
      </ul>
    </div>
  </section>
  <section>
    <h3 class='game-info__title'>Principles of the training</h3>
    <div class='game-info__desc'>
      <ul>
        <li>
          The game trains attention, short-term memory and spatial orientation. With a time-limited option, the
          difficulty increases.
        </li>
        <li>
          First, it is necessary to visually "scan" the entire square and detect all the marked boxes, which requires a
          high degree of attention.
        </li>
        <li>
          Fixing the position of highlighted boxes and re-marking them in an empty square develops memory.
        </li>
        <li>
          Specifying squares in a rotated square supports the development of spatial imagination and orientation.
        </li>
      </ul>
    </div>
  </section>
  <section>
    <h3 class='game-info__title'>How to play this game</h3>
    <div class='game-info__desc'>
      <p>
        Your task is to remember the positions of all colored squares in the matrix. After they disappear, mark the
        positions on which the colored squares were located. Be careful: the matrix turns around after the squares
        disappear.
        
        <img src='./assets/rotate-matrix/roto_pole_help_trn.png' alt=''>
        
        You earn points for each correct position. Once you have correctly marked all the positions in that round, you
        will get a bonus.
        
        After each successful round, the difficulty increases. On the contrary, after a round that is unsuccessful
        (i.e., one in which you place the squares incorrectly twice), the difficulty will be reduced.
      </p>
    </div>
  </section>
</div>
<script>
	const options = {
		width: 615,
		height: 505,
		transparent: false,
		backgroundColor: 0XEEEEEE
	}
	const app = new PIXI.Application(options)
	let clickSound, successSound, errorSound
	const countTime = 1000
	let angle = 30
	
	function initSound () {
		// 声音
		const manifest = {
			success: './assets/sound/success.mp3',
			click: './assets/sound/click.mp3',
			error: './assets/sound/error.mp3',
			levelwon: './assets/sound/levelwon.mp3',
			flip: './assets/sound/flip.mp3'
		}
		
		// add to PIXI loader
		PIXI.sound.volumeAll = 100
		for (let resource in manifest) {
			PIXI.Loader.shared.add(resource, manifest[resource])
		}
		// preload the sounds
		PIXI.Loader.shared.load(function (loader, resources) {
			clickSound = resources['click'].sound
			successSound = resources['success'].sound
			errorSound = resources['error'].sound
		})
	}
	
	const playground = document.querySelector('.playground')
	playground.appendChild(app.view)
	
	const centerX = app.renderer.view.width / 2
	const centerY = app.renderer.view.height / 2
	const loader = new PIXI.Loader()
	const Sprite = PIXI.Sprite
	const Texture = PIXI.Texture
	
	let currentScene = 0
	
	let playBtnActiveTexture, playBtnTexture, playButton,
		welcomeScene, introScene, gameScene,
		correctBtn, failBtn,
		countOne, countTwo, countThree, counterInterval, countSet = [],
		correctAnswer = [], correctAnswerSprites = [], clickRightCount = 0, clickWrongCount = 0,
		textureCache,
		level = 1, matrix = [], boxGroup,
		rightBoxTexture, wrongBoxTexture, orangeBoxTexture
	
	let transform = {
		x: 0
	}
	let introTransform = {
		posX: -centerX * 2
	}
	let gameTransform = {
		x: -centerX * 2
	}
	
	// 加载图片转化成纹理
	loader
	.add('welcome', './assets/rotate-matrix/en/title_screen.png')
	.add('intro', './assets/rotate-matrix/en/instructions.png')
	.add('correctImg', './assets/rotate-matrix/common/sign_ok.png')
	.add('failImg', './assets/rotate-matrix/common/sign_fail.png')
	
	.add('rectBackgroundImg', './assets/rotate-matrix/common/rectBackground.png')
	.add('rectGrayImg', './assets/rotate-matrix/common/rectGray.png')
	.add('rectGreenImg', './assets/rotate-matrix/common/rectGreen.png')
	.add('rectOrangeImg', './assets/rotate-matrix/common/rectOrange.png')
	.add('rectRedImg', './assets/rotate-matrix/common/rectRed.png')
	
	.add('gameBackground', './assets/rotate-matrix/common/gameBackground.png')
	.add('playBtn', './assets/rotate-matrix/en/button_play.png')
	.add('counts', './assets/rotate-matrix/common/counts.png')
	.load(setup)
	
	// 补零
	function zeroFill (num) {
		return num < 10 ? '0' + num : num
	}
	
	function getRangeNum (min, max) {
		return Math.floor(Math.random() * (max - min)) + min
	}
	
	// 游戏业务代码
	// todo flip 效果极差
	function renderGameLogic () {
		console.log(level, '当前关数')
		/*
		* 闯关游戏, 12次操作机会，无时间限制，测试闯关数
		* box = 1, 2 时，1次成功晋级，box > 2, 2次成功晋级
		*
		* box = 1, 矩形大小为 2x2
		* box = 2，矩形大小为 3x3
		* box = 3，矩形大小为 4x3
		* box = 4，矩形大小为 4x3
		* box = 5，矩形大小为 4x4
		* box = 6，矩形大小为 5x4
		* box = 7，矩形大小为 5x4
		* box = 8，矩形大小为 5x5
		*
		* 随机出现level数量的box，在level1 ~ level7 均clockwise旋转30°，level8↑，逆时针旋转45°
		* 点击刚出现的box，判断正误
		*
		* */
		let matrixStructure = [
			{row: 2, col: 2},
			{row: 3, col: 3},
			{row: 4, col: 3},
			{row: 4, col: 3},
			{row: 4, col: 4},
			{row: 5, col: 4},
			{row: 5, col: 4},
			{row: 5, col: 5}
		]
		level > 8 && (level = 8)
		let currentMatrix = matrixStructure[level - 1]
		let num = 0
		for (let i = 0; i < currentMatrix.row; i++) {
			matrix[i] = []
			for (let j = 0; j < currentMatrix.col; j++) {
				num++
				matrix[i].push(num)
			}
		}
		
		correctAnswer.length = 0
		correctAnswerSprites.length = 0
		clickRightCount = 0
		clickWrongCount = 0
		if (boxGroup !== undefined && boxGroup.children.length) {
			gameScene.removeChild(boxGroup)
		}
		
		// 初始化所有sprite 及 container
		boxGroup = new PIXI.Container()
		const foundation = new Sprite(textureCache['rectBackgroundImg'])
		const grayBox = new Sprite(textureCache['rectGrayImg'])
		rightBoxTexture = textureCache['rectGreenImg']
		wrongBoxTexture = textureCache['rectRedImg']
		orangeBoxTexture = textureCache['rectOrangeImg']
		
		const grayTexture = textureCache['rectGrayImg']
		
		foundation.anchor.set(0.5)
		foundation.x = centerX
		foundation.y = centerY
		
		// 展示矩阵
		let squares = []
		
		const flipTime = 300
		
		const rect = matrix.flat()
		const row = matrix[0].length
		const col = matrix.length
		
		// 起始点的x,y 轴
		foundation.height = row * grayBox.height + 20
		foundation.width = col * grayBox.width + 20
		boxGroup.addChild(foundation)
		
		for (let i = 0; i < matrix.length; i++) {
			for (let j = 0; j < matrix[i].length; j++) {
				let gray = new Sprite(textureCache['rectGrayImg'])
				let startX = centerX - (col - 1) * gray.width / 2
				let startY = centerY - (row - 1) * gray.height / 2
				gray.name = `${i}-${j}`
				gray.anchor.set(0.5)
				gray.x = startX + gray.width * i
				gray.y = startY + gray.height * j
				boxGroup.addChild(gray)
				squares.push(gray)
			}
		}
		
		boxGroup.pivot.set(centerX, centerY)
		boxGroup.x = centerX
		boxGroup.y = centerY
		
		gameScene.addChild(boxGroup)
		
		// foundation 旋转动画
		const foundationAngle = {
			angle: 0
		}
		const foundationTween = new TWEEN.Tween(foundationAngle)
		.to({
			angle
		}, flipTime)
		.onUpdate(result => {
			boxGroup.angle = result.angle
		})
		
		// 根据level 确定正确答案数量及name
		let scaleTransform = {
			x: 1
		}
		while (correctAnswer.length < level) {
			let index = getRangeNum(0, squares.length)
			let temp = squares[index]
			if (!correctAnswer.includes(squares[index].name)) {
				correctAnswer.push(squares[index].name)
				correctAnswerSprites.push(squares[index])
				let scaleTween = new TWEEN.Tween(scaleTransform)
				.delay(300)
				.to({
					x: -1
				}, flipTime)
				.onUpdate(result => {
					temp.scale.x = result.x
				})
				.onComplete(() => {
					temp.texture = orangeBoxTexture
				})
				
				let resetScale = new TWEEN.Tween(scaleTransform)
				.delay(2000)
				.to({
					x: 1
				}, flipTime)
				.onUpdate(result => {
					temp.scale.x = result.x
					temp.texture = grayTexture
				})
				
				scaleTween.chain(resetScale)
				resetScale.chain(foundationTween)
				scaleTween.start()
			}
		}
		
		for (let item of squares) {
			item.interactive = true
			item.buttonMode = true
			item.on('pointerdown', () => {
				checkHint(item)
			})
		}
	}
	
	// 游戏开始倒计时
	function renderCount (sprites) {
		console.log('renderCount')
		const three = sprites[2]
		const two = sprites[1]
		const one = sprites[0]
		
		const countAnimate = (obj, callback) => {
			console.log(obj, 'countAnimate')
			obj.visible = true
			const scales = {x: obj.scale.x, y: obj.scale.y}
			const tween = new TWEEN.Tween(scales)
			
			tween.to({
				x: 0.5,
				y: 0.5
			}, countTime)
			.onUpdate(result => {
				obj.scale.set(result.x, result.y)
			})
			.onComplete(() => {
				app.stage.removeChild(obj)
				callback && callback()
			})
			return tween
		}
		const threeStart = countAnimate(three)
		const twoStart = countAnimate(two)
		const oneStart = countAnimate(one, () => {
			renderGameLogic()
			renderToolbar(400)
			checkHint()
			TWEEN.remove(threeStart)
			TWEEN.remove(twoStart)
			TWEEN.remove(oneStart)
		})
		
		threeStart.chain(twoStart)
		twoStart.chain(oneStart)
		
		threeStart.start()
	}
	
	// 游戏计时及计分
	function renderToolbar (remains) {
		const toolbars = new PIXI.Container()
		const statue = new PIXI.Graphics()
		let time = remains
		let remainTime = null
		statue.beginFill(0X000000, 0.5)
		statue.drawRect(0, 0, centerX * 2, 40)
		statue.endFill()
		toolbars.addChild(statue)
		let textStyle = new PIXI.TextStyle({
			fontFamily: 'PingFang SC Regular',
			fontSize: 18,
			fill: '#FFFFFF',
			stroke: '#cd0000',
			align: 'center',
			lineHeight: 40,
			textBaseline: 'middle'
		})
		gameScene.addChild(toolbars)
		
		const renderText = () => {
			remainTime = new PIXI.Text(`Remaining time: 00:${zeroFill(time)}`, textStyle)
			remainTime.resolution = 2
			remainTime.x = centerX - remainTime.width / 2
			remainTime.y = 5
			toolbars.addChild(remainTime)
		}
		
		renderText()
		
		counterInterval = setInterval(() => {
			remainTime && toolbars.removeChild(remainTime)
			if (time === 0) {
				gameOverHandler()
			}
			if (time > 0) {
				time--
			}
			renderText()
		}, 1000)
	}
	
	// 游戏结束逻辑
	function gameOverHandler () {
		clearInterval(counterInterval)
		const tween = new TWEEN.Tween(gameScene.position)
		.to({
			x: centerX * 2
		})
		.onUpdate(result => {
			gameScene.x = result.x
		})
		.onComplete(() => {
			app.stage.removeChild(gameScene)
			const gameOverText = new PIXI.Text('GAME OVER', {
				fontSize: 48,
				fill: 0XEA432B,
				fontWeight: 800
			})
			const alpha = {
				val: 0
			}
			gameOverText.y = centerY - gameOverText.height / 2
			gameOverText.x = centerX - gameOverText.width / 2
			gameOverText.alpha = alpha.val
			app.stage.addChild(gameOverText)
			
			const alphaTween = new TWEEN.Tween(alpha)
			.to({
				val: 1
			})
			.onUpdate(result => {
				gameOverText.alpha = result.val
			})
			alphaTween.start()
		})
		tween.start()
	}
	
	// 游戏正误提示
	
	// 错误正确判断 及计数
	
	function checkHint (square) {
		console.log(correctAnswer, '移除之前')
		if (!square) return
		const getIndexByName = name => {
			let index
			for (let i = 0; i < correctAnswer.length; i++) {
				if (correctAnswer[i] === name) {
					index = i
					break
				}
			}
			return index
		}
		if (correctAnswer.includes(square.name)) {
			// 回答正确
			square.texture = rightBoxTexture
			successSound.play()
			clickRightCount++
			correctAnswer.splice(getIndexByName(square.name), 1)
			if (clickRightCount === level) {
				level++
				renderGameLogic()
			}
		} else {
			// 回答错误
			square.texture = wrongBoxTexture
			errorSound.play()
			clickWrongCount++
			if (clickWrongCount === 3) {
				level--
				for (let i = 0; i < correctAnswer.length; i++) {
					let sprite = boxGroup.getChildByName(correctAnswer[i])
					sprite.texture = orangeBoxTexture
				}
				renderGameLogic()
			}
		}
		square.removeAllListeners()
		console.log(square)
	}
	
	// 初始化多个游戏场景, start -> introduce -> ready
	function setup () {
		initSound()
		textureCache = PIXI.utils.TextureCache
		const {
			welcome,
			playBtn,
			intro,
			gameBackground,
			counts,
			correctImg,
			failImg
		} = textureCache
		
		// 游戏元素
		
		welcomeScene = new Sprite(new Texture(welcome))
		introScene = new Sprite(new Texture(intro))
		
		welcomeScene.x = transform.x
		introScene.x = introTransform.posX
		
		playBtnTexture = new Texture(playBtn)
		playBtnTexture.frame = new PIXI.Rectangle(0, 0, 200, 53)
		
		playBtnActiveTexture = new Texture(playBtn)
		playBtnActiveTexture.frame = new PIXI.Rectangle(0, 53, 200, 53)
		
		playButton = new Sprite(playBtnTexture)
		playButton.x = (centerX * 2 - playButton.width) / 2
		playButton.y = centerY * 2 - 80
		
		playButton.interactive = true
		playButton.buttonMode = true
		
		playButton.on('pointerdown', playHandler)
		playButton.on('pointerup', playUpHandler)
		
		app.stage.addChild(welcomeScene)
		app.stage.addChild(introScene)
		app.stage.addChild(playButton)
		
		// gameContent
		let gameBg = new Sprite(new Texture(gameBackground))
		
		gameScene = new PIXI.Container()
		gameScene.x = gameTransform.x
		gameScene.addChild(gameBg)
		app.stage.addChild(gameScene)
		
		const countOneTexture = new PIXI.Texture(counts)
		countOneTexture.frame = new PIXI.Rectangle(0, 0, 200, 200)
		countOne = new Sprite(countOneTexture)
		countSet.push(countOne)
		
		const countTwoTexture = new PIXI.Texture(counts)
		countTwoTexture.frame = new PIXI.Rectangle(200, 0, 200, 200)
		countTwo = new Sprite(countTwoTexture)
		countSet.push(countTwo)
		
		const countThreeTexture = new PIXI.Texture(counts)
		countThreeTexture.frame = new PIXI.Rectangle(400, 0, 200, 200)
		countThree = new Sprite(countThreeTexture)
		countSet.push(countThree)
		
		for (let item of countSet) {
			item.anchor.set(0.5, 0.5)
			item.scale.set(0.3)
			item.x = centerX
			item.y = centerY
			item.visible = false
			app.stage.addChild(item)
		}
		
		// correct fail hint
		correctBtn = new Sprite(new PIXI.Texture(correctImg))
		correctBtn.anchor.set(0.5)
		correctBtn.y = centerY - correctBtn.height / 2
		correctBtn.x = 80
		correctBtn.scale.set(0.5)
		correctBtn.alpha = 0
		
		failBtn = new Sprite(new PIXI.Texture(failImg))
		failBtn.anchor.set(0.5)
		failBtn.y = centerY - correctBtn.height / 2
		failBtn.x = 80
		failBtn.scale.set(0.5)
		failBtn.alpha = 0
		
		app.stage.addChild(correctBtn)
		app.stage.addChild(failBtn)
	}
	
	function playHandler (e) {
		e.stopPropagation()
		let self = this
		clickSound.play()
		self.texture = playBtnActiveTexture
		if (currentScene === 0) {
			const tween = new TWEEN.Tween(transform)
			.to({
				x: centerX * 2
			}, 500)
			.onUpdate(updateScene1Handler)
			.onComplete(() => {
				currentScene = 1
			})
			
			const introSceneTween = new TWEEN.Tween(introTransform)
			.to({
				posX: 0
			}, 500)
			.onUpdate(updateScene2Handler)
			
			tween.start()
			introSceneTween.start()
			
			function updateScene1Handler (object) {
				welcomeScene.x = object.x
			}
			
			function updateScene2Handler (object) {
				introScene.x = object.posX
			}
		}
		if (currentScene === 1) {
			self.alpha = 0
			const tween = new TWEEN.Tween(gameTransform)
			.to({
				x: 0
			}, 500)
			.onUpdate(obj => {
				gameScene.x = obj.x
			})
			const introTrans = new TWEEN.Tween(introTransform)
			.to({
				posX: centerX * 2
			}, 500)
			.onUpdate(obj => {
				introScene.x = obj.posX
			})
			.onComplete(() => {
				app.stage.removeChild(playButton)
				renderCount(countSet)
			})
			
			tween.start()
			introTrans.start()
		}
	}
	
	function playUpHandler (e) {
		e.stopPropagation()
		this.texture = playBtnTexture
	}
	
	animate()
	
	function animate () {
		requestAnimationFrame(animate)
		TWEEN.update()
	}

</script>
</body>
</html>
